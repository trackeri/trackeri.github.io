<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Upravitelj Uređajima</title>


    <!-- Vaš CSS ide ovdje -->
    <style>
        :root {
            --background-color: #f0f2f5; /* Svjetlija, mekša pozadina */
            --text-color: #333;
            --border-color: #e0e0e0; /* Svjetliji border */
            --header-bg: #4CAF50; /* Zadržana zelena */
            --header-text: white;
            --button-bg: #4CAF50;
            --button-hover-bg: #45a049;
            --input-bg: white;
            --input-border: #ccc;
            --list-item-hover: #e8f5e9; /* Svjetlija zelena za hover */
            --modal-bg: rgba(0, 0, 0, 0.5);
            --modal-content-bg: white;
            --battery-low: #f44336;
            --battery-medium: #ffc107;
            --battery-high: #4caf50;
            --active-item-bg: #dcedc8; /* Mekša zelena za aktivnu stavku */
            --warning-color: #ff9800; /* Narančasta za upozorenja */
            --critical-color: #FF0000; /* Crvena za kritično upozorenje */
            --edit-btn-bg: #2196f3; /* Plava za Uredi */
            --edit-btn-hover-bg: #1976d2;
            --delete-btn-bg: #f44336; /* Crvena za Obriši */
            --delete-btn-hover-bg: #d32f2f;
            /* Tab specific colors (only for mobile) */
            --tab-bg: #e0e0e0;
            --tab-text: #555;
            --tab-active-bg: #4CAF50;
            --tab-active-text: white;
            --tab-hover-bg: #c8e6c9;
            /* Heights for layout calculation */
            --header-height: 50px; /* Smanjena visina zaglavlja */
            --tab-nav-height: 50px;
        }

        body.dark-mode {
            --background-color: #263238; /* Tamnija, mekša pozadina */
            --text-color: #e0e0e0;
            --border-color: #455a64; /* Tamniji border */
            --header-bg: #388e3c;
            --header-text: white;
            --button-bg: #388e3c;
            --button-hover-bg: #2e7d32;
            --input-bg: #37474f; /* Tamniji input */
            --input-border: #546e7a;
            --list-item-hover: #3d5a6f; /* Tamnija plava/siva za hover */
            --modal-bg: rgba(0, 0, 0, 0.7);
            --modal-content-bg: #37474f;
            --active-item-bg: #4caf50; /* Tamnija zelena za aktivnu stavku */
            --warning-color: #fb8c00; /* Tamnija narančasta za upozorenja */
            --critical-color: #D32F2F; /* Tamnija crvena za kritično upozorenje */
            --edit-btn-bg: #1565c0; /* Tamnija plava za Uredi */
            --edit-btn-hover-bg: #0d47a1;
            --delete-btn-bg: #c62828; /* Tamnija crvena za Obriši */
            --delete-btn-hover-bg: #b71c1c;
            /* Tab specific colors - dark mode (only for mobile) */
            --tab-bg: #455a64;
            --tab-text: #e0e0e0;
            --tab-active-bg: #388e3c;
            --tab-active-text: white;
            --tab-hover-bg: #546e7a;
            /* Heights for layout calculation */
            --header-height: 50px;
            --tab-nav-height: 50px;
        }

        body {
            font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
            background-color: var(--background-color);
            color: var(--text-color);
            transition: background-color 0.3s, color 0.3s;
        }

        header {
            background-color: var(--header-bg);
            color: var(--header-text);
            padding: 10px 15px; /* Smanjen padding */
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            flex-shrink: 0; /* Prevent header from shrinking */
            height: var(--header-height); /* Explicitly set header height */
            min-height: var(--header-height); /* Ensure it doesn't shrink below this */
        }

            header h1 {
                margin: 0;
                font-size: 1.6em; /* Smanjen font size */
            }

        .header-controls {
            display: flex;
            align-items: center;
            gap: 15px; /* Smanjen razmak */
        }

        .settings-icon-button {
            background: none;
            border: none;
            cursor: pointer;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--header-text);
            transition: transform 0.2s ease-in-out;
        }

            .settings-icon-button:hover {
                transform: rotate(30deg);
            }

            .settings-icon-button svg {
                width: 22px; /* Smanjena ikona */
                height: 22px;
                fill: currentColor;
            }

        .notification-test-button, .my-location-button {
            background-color: #007bff; /* Plava boja za notifikaciju */
            color: white;
            border: none;
            border-radius: 5px;
            padding: 8px 15px;
            cursor: pointer;
            font-size: 0.9em;
            transition: background-color 0.2s;
        }

            .notification-test-button:hover, .my-location-button:hover {
                background-color: #0056b3;
            }


        .toggle-container {
            display: flex;
            align-items: center;
            gap: 8px; /* Smanjen razmak */
        }

            .toggle-container span {
                font-size: 0.9em; /* Adjusted to match other text */
            }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px; /* Smanjen prekidač */
            height: 28px; /* Smanjen prekidač */
        }

            .toggle-switch input {
                opacity: 0;
                width: 0;
                height: 0;
            }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: 0.4s;
            border-radius: 28px; /* Prilagođen border-radius */
        }

            .slider:before {
                position: absolute;
                content: "";
                height: 20px; /* Smanjen krug */
                width: 20px; /* Smanjen krug */
                left: 4px;
                bottom: 4px;
                background-color: white;
                transition: 0.4s;
                border-radius: 50%;
            }

        input:checked + .slider {
            background-color: #2196f3;
        }

            input:checked + .slider:before {
                transform: translateX(22px); /* Prilagođen pomak */
            }

        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .device-list-container {
            width: 350px;
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            padding: 15px;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.05);
            overflow-y: auto;
            flex-shrink: 0;
        }

        .device-list-controls {
            display: flex;
            flex-wrap: wrap; /* Allow buttons to wrap */
            gap: 10px;
            margin-bottom: 15px;
        }

            .device-list-controls button {
                padding: 8px 15px;
                background-color: var(--button-bg);
                color: var(--header-text);
                border: none;
                border-radius: 5px;
                cursor: pointer;
                font-size: 0.9em;
                transition: background-color 0.2s;
            }

                .device-list-controls button:hover {
                    background-color: var(--button-hover-bg);
                }

        .search-filter-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
        }

            .search-filter-container input,
            .search-filter-container select {
                padding: 8px;
                border: 1px solid var(--input-border);
                border-radius: 5px;
                background-color: var(--input-bg);
                color: var(--text-color);
                font-size: 0.9em;
            }

        .device-list {
            flex: 1;
            overflow-y: auto;
        }

        .device-item {
            padding: 12px 10px;
            border-bottom: 1px solid var(--border-color);
            cursor: pointer;
            transition: background-color 0.2s;
            display: flex;
            flex-direction: column; /* Changed to column for stacking */
            gap: 5px; /* Spacing between rows */
            position: relative;
        }

            .device-item:hover {
                background-color: var(--list-item-hover);
            }

            .device-item.active {
                background-color: var(--active-item-bg);
            }

        .device-info-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
        }

        .device-name {
            font-weight: bold;
            font-size: 1.1em;
            flex-grow: 1; /* Allow name to take available space */
        }

        .device-icons-and-buttons {
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
        }

        .device-icons {
            display: flex;
            align-items: center;
            gap: 8px; /* Space between icons */
        }

        .battery-status {
            font-size: 0.9em;
            color: #666;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .battery-icon {
            width: 20px;
            height: 12px;
            border: 1px solid currentColor;
            border-radius: 2px;
            position: relative;
            overflow: hidden;
        }

            .battery-icon::after {
                content: "";
                position: absolute;
                top: 2px;
                right: -4px;
                width: 2px;
                height: 8px;
                background-color: currentColor;
                border-radius: 1px;
            }

        .battery-level {
            height: 100%;
            background-color: currentColor;
            border-radius: 1px;
            position: absolute;
            top: 0;
            left: 0;
        }

        .battery-low-color {
            color: var(--battery-low);
        }

        .battery-medium-color {
            color: var(--battery-medium);
        }

        .battery-high-color {
            color: var(--battery-high);
        }

        /* General map container styling */
        .map-container, #map-tab {
            flex: 1; /* Both map containers should take available space */
            background-color: #e0e0e0;
            display: flex;
            justify-content: center;
            align-items: center;
            /* Ensure they have a height to render the map */
            min-height: 200px; /* Minimum height for map visibility */
        }

        #map, #mapMobile {
            width: 100%;
            height: 100%;
        }

        /* Modal for settings/configuration */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: var(--modal-bg);
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background-color: var(--modal-content-bg);
            margin: auto;
            padding: 30px; /* Povećan padding */
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            width: 90%;
            max-width: 500px; /* Dodan max-width za bolji izgled */
            text-align: center;
            color: var(--text-color);
        }

            .modal-content h2 {
                margin-top: 0;
                color: var(--header-bg);
            }

            .modal-content textarea {
                width: calc(100% - 20px);
                min-height: 150px;
                padding: 10px;
                margin-bottom: 20px;
                border: 1px solid var(--input-border);
                border-radius: 5px;
                font-family: monospace;
                background-color: var(--input-bg);
                color: var(--text-color);
                resize: vertical;
            }

            .modal-content .form-group { /* Specifično za modalni sadržaj */
                margin-bottom: 15px;
                text-align: left; /* Poravnanje lijevo unutar modaala */
            }

            .modal-content label { /* Specifično za modalni sadržaj */
                display: block;
                margin-bottom: 5px;
                font-weight: bold;
                font-size: 0.95em;
            }

            .modal-content input[type="text"],
            .modal-content input[type="number"],
            .modal-content select {
                width: calc(100% - 22px);
                padding: 10px;
                border: 1px solid var(--input-border);
                border-radius: 5px;
                background-color: var(--input-bg);
                color: var(--text-color);
                font-size: 1em;
            }

            .modal-content .form-actions { /* Specifično za modalni sadržaj */
                display: flex;
                justify-content: center; /* Centriranje gumba */
                gap: 10px;
                margin-top: 20px;
            }

                .modal-content .form-actions button {
                    padding: 10px 25px;
                    background-color: var(--button-bg);
                    color: white;
                    border: none;
                    border-radius: 5px;
                    cursor: pointer;
                    font-size: 1.1em;
                    transition: background-color 0.2s;
                }

                    .modal-content .form-actions button:hover {
                        background-color: var(--button-hover-bg);
                    }

        /* Device Form Modal */
        .device-form-modal .modal-content {
            max-width: 600px;
            padding: 25px;
        }

        .device-form-modal h2 {
            margin-bottom: 20px;
            font-size: 1.6em;
        }

        .device-form-modal .form-group {
            margin-bottom: 15px;
            text-align: left;
        }

        .device-form-modal label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            font-size: 0.95em;
        }

        .device-form-modal input[type="text"],
        .device-form-modal input[type="number"],
        .device-form-modal select {
            width: calc(100% - 22px);
            padding: 10px;
            border: 1px solid var(--input-border);
            border-radius: 5px;
            background-color: var(--input-bg);
            color: var(--text-color);
            font-size: 1em;
        }

        .device-form-modal input[readonly] {
            background-color: #e9e9e9;
            cursor: not-allowed;
        }

        body.dark-mode .device-form-modal input[readonly] {
            background-color: #555;
        }

        .device-form-modal .form-actions {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 20px;
        }

            .device-form-modal .form-actions button {
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 1em;
                transition: background-color 0.2s;
            }

            .device-form-modal .form-actions .submit-btn {
                background-color: var(--button-bg);
                color: white;
                border: none;
            }

                .device-form-modal .form-actions .submit-btn:hover {
                    background-color: var(--button-hover-bg);
                }

            .device-form-modal .form-actions .cancel-btn {
                background-color: #ccc;
                color: #333;
                border: none;
            }

        body.dark-mode .device-form-modal .form-actions .cancel-btn {
            background-color: #555;
            color: #e0e0e0;
        }

        .device-form-modal .form-actions .cancel-btn:hover {
            background-color: #bbb;
        }

        body.dark-mode .device-form-modal .form-actions .cancel-btn:hover {
            background-color: #666;
        }

        .battery-filter-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        /* Confirmation Modal Specific Styles */
        .confirm-modal .modal-content {
            max-width: 400px;
        }

        .confirm-modal .modal-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
        }

            .confirm-modal .modal-buttons button {
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 1em;
                transition: background-color 0.2s;
            }

            .confirm-modal .modal-buttons .confirm-btn {
                background-color: #f44336; /* Red for delete */
                color: white;
                border: none;
            }

                .confirm-modal .modal-buttons .confirm-btn:hover {
                    background-color: #d32f2f;
                }

            .confirm-modal .modal-buttons .cancel-btn {
                background-color: #ccc;
                color: #333;
                border: none;
            }

        body.dark-mode .confirm-modal .modal-buttons .cancel-btn {
            background-color: #555;
            color: #e0e0e0;
        }

        .confirm-modal .modal-buttons .cancel-btn:hover {
            background-color: #bbb;
        }

        body.dark-mode .confirm-modal .modal-buttons .cancel-btn:hover {
            background-color: #666;
        }

        /* Warning icon style */
        .warning-icon {
            color: var(--warning-color);
            font-size: 1.2em;
            margin-left: 5px;
            vertical-align: middle;
            display: inline-block; /* Dodano za bolje renderiranje */
        }

            .warning-icon svg {
                width: 1em; /* Adjust size relative to font-size */
                height: 1em;
                fill: currentColor; /* Inherit color from parent */
            }

        /* Critical icon style */
        .critical-icon {
            color: var(--critical-color);
            font-size: 1.2em;
            margin-left: 5px;
            vertical-align: middle;
            display: inline-block; /* Dodano za bolje renderiranje */
        }

            .critical-icon svg {
                width: 1em; /* Adjust size relative to font-size */
                height: 1em;
                fill: currentColor; /* Inherit color from parent */
            }


        /* --- Mobile Specific Styles (Tabs) --- */
        .tab-navigation {
            display: none; /* Hidden by default on desktop */
            width: 100%;
            background-color: var(--tab-bg);
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
            height: var(--tab-nav-height); /* Explicitly set tab nav height */
            min-height: var(--tab-nav-height);
        }

            .tab-navigation button {
                flex: 1;
                padding: 12px 0;
                border: none;
                background-color: transparent;
                color: var(--tab-text);
                font-size: 1em;
                cursor: pointer;
                transition: background-color 0.2s, color 0.2s;
                border-bottom: 3px solid transparent;
            }

                .tab-navigation button:hover {
                    background-color: var(--tab-hover-bg);
                }

                .tab-navigation button.active-tab {
                    background-color: var(--tab-active-bg);
                    color: var(--tab-active-text);
                    border-bottom-color: var(--tab-active-text);
                }

        .tab-content-container {
            display: none; /* Hidden by default on desktop */
            flex: 1;
            flex-direction: column;
            overflow: hidden;
            height: calc(100vh - var(--header-height) - var(--tab-nav-height));
            max-height: calc(100vh - var(--header-height) - var(--tab-nav-height)); /* Ensure it doesn't overflow */
        }

        .tab-pane {
            display: none; /* Hidden by default */
            flex-direction: column;
            flex: 1;
            overflow-y: auto;
            padding: 15px;
        }

            .tab-pane.active {
                display: flex; /* Show active tab */
            }

        /* Map tab specific styles to ensure it takes full height */
        #map-tab {
            padding: 0; /* Remove padding for map to take full space */
            overflow: hidden;
        }

        /* Adjustments for filter/list controls within tabs */
        #filter-tab .device-list-controls,
        #list-tab .device-list-controls {
            margin-bottom: 15px;
            justify-content: flex-start; /* Align buttons to start */
        }

        #filter-tab .search-filter-container {
            border-bottom: none; /* Remove border when inside tab */
            padding-bottom: 0;
        }

        /* --- Responsive Design Media Queries --- */
        @media (max-width: 768px) {
            header {
                flex-direction: row; /* Keep header items in a row */
                justify-content: space-between;
                padding: 10px 15px; /* Smaller padding */
            }

                header h1 {
                    font-size: 1.1em; /* Smaller title for mobile */
                    flex-shrink: 1;
                    min-width: 0; /* Allow text to truncate */
                    white-space: nowrap; /* Prevent wrapping */
                    overflow: hidden; /* Hide overflow */
                    text-overflow: ellipsis; /* Add ellipsis if truncated */
                    max-width: calc(100% - 120px); /* Give space for controls (approx 60px toggle + 24px settings + gaps) */
                }

            .header-controls {
                gap: 10px; /* Smaller gap */
                flex-shrink: 0; /* Prevent controls from shrinking */
            }

            .toggle-container span {
                /* display: none; */ /* Keep the span visible for the toggle */
                font-size: 0.8em; /* Smaller font for mobile */
            }

            .toggle-container {
                min-width: 60px; /* Ensure toggle switch has enough space */
                justify-content: flex-end; /* Align toggle to end within its container */
                padding-right: 5px; /* Add a little padding to the right edge */
            }

            .settings-icon-button {
                padding-left: 5px; /* Add a little padding to the left edge */
            }

            .main-content {
                flex-direction: column; /* Stack vertically on mobile */
            }

            .device-list-container {
                display: none; /* Hide the original desktop list container on mobile */
            }

            .map-container {
                display: none; /* Hide the original desktop map container on mobile */
            }

            /* Show tab navigation and content container on mobile */
            .tab-navigation {
                display: flex;
            }

            .tab-content-container {
                display: flex;
            }

            .tab-pane {
                height: 100%; /* Make tab panes take full height of their container */
                overflow-y: auto; /* Allow scrolling within tab panes */
            }

            #map-tab {
                height: 100%; /* Map tab should take full height of tab-content-container */
            }
        }

        @media (max-width: 480px) {
            .device-list-controls button {
                width: 100%; /* Full width buttons on very small screens */
                margin-bottom: 5px;
            }

            .toggle-container span {
                display: none; /* Hide text for dark mode toggle on very small mobile */
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>Upravitelj Uređajima</h1>
        <div class="header-controls">
            <button id="testNotificationBtn" class="notification-test-button" title="Testiraj Notifikaciju">Test Notifikacija</button>
            <button id="myLocationBtn" class="my-location-button" title="Moja Trenutna Lokacija">Moja Lokacija</button>
            <button id="settingsBtn" class="settings-icon-button" title="Postavke">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M12 15.5A3.5 3.5 0 0 0 15.5 12A3.5 3.5 0 0 0 12 8.5A3.5 3.5 0 0 0 8.5 12A3.5 3.5 0 0 0 12 15.5ZM19.4 12.9L21.75 12C21.92 11.59 21.92 11.41 21.75 11L19.4 10.1L18.08 8.07L19.1 5.76L17.24 4.1L14.93 5.13L12.9 3.82L12 1.47C11.59 1.29 11.41 1.29 11 1.47L10.1 3.82L8.07 5.13L5.76 4.1L4.1 5.76L5.13 8.07L3.82 10.1L1.47 11C1.29 11.41 1.29 11.59 1.47 12L3.82 12.9L5.13 14.93L4.1 17.24L5.76 18.9L8.07 17.87L10.1 19.18L11 21.53C11.41 21.71 11.59 21.71 12 21.53L12.9 19.18L14.93 17.87L17.24 18.9L18.9 17.24L17.87 14.93L19.18 12.9H19.4Z" />
                </svg>
            </button>
            <div class="toggle-container">
                <span>Svijetli / Tamni način</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="darkModeToggle" />
                    <span class="slider"></span>
                </label>
            </div>
        </div>
    </header>

    <div class="main-content">
        <!-- Desktop/Tablet Layout: Device List and Map side-by-side -->
        <div class="device-list-container">
            <div class="device-list-controls">
                <button id="addDeviceBtn">Dodaj uređaj</button>
                <button id="refreshDevicesBtn">Osvježi</button>
                <button id="clearSearchBtn">Obriši pretragu</button>
            </div>
            <div class="search-filter-container">
                <input type="text"
                       id="searchName"
                       placeholder="Pretraži po nazivu..." />
                <select id="filterType">
                    <option value="">Svi tipovi</option>
                    <option value="1">Admin</option>
                    <option value="2">Privatno</option>
                    <option value="3">Statično</option>
                </select>
                <div class="battery-filter-group">
                    <label for="filterBattery">Baterija:</label>
                    <select id="filterBattery">
                        <option value="">Svi</option>
                        <option value="10">&lt; 10%</option>
                        <option value="50">&lt; 50%</option>
                        <option value="70">&lt; 70%</option>
                        <option value="80">&lt; 80%</option>
                        <option value="90">&lt; 90%</option>
                    </select>
                </div>
                <div class="distance-filter-group">
                    <label for="filterDistance">Udaljenost (m):</label>
                    <select id="filterDistance">
                        <option value="">Svi</option>
                        <option value="5">&gt; 5m</option>
                        <option value="10">&gt; 10m</option>
                        <option value="20">&gt; 20m</option>
                        <option value="30">&gt; 30m</option>
                        <option value="40">&gt; 40m</option>
                        <option value="50">&gt; 50m</option>
                        <option value="70">&gt; 70m</option>
                        <option value="100">&gt; 100m</option>
                    </select>
                </div>
                <div class="last-update-filter-group">
                    <label for="filterLastUpdate">Zadnja Izmjena (min):</label>
                    <select id="filterLastUpdate">
                        <option value="">Svi</option>
                        <option value="10">&gt; 10 min</option>
                        <option value="20">&gt; 20 min</option>
                        <option value="30">&gt; 30 min</option>
                        <option value="40">&gt; 40 min</option>
                        <option value="50">&gt; 50 min</option>
                        <option value="100">&gt; 100 min</option>
                    </select>
                </div>
            </div>
            <div class="device-list" id="deviceList">
                <!-- Device items will be loaded here -->
            </div>
        </div>
        <div class="map-container">
            <div id="map"></div>
        </div>

        <!-- Mobile Specific Layout: Tab Navigation and Tab Content -->
        <!-- Tab Navigation for Mobile/Responsive -->
        <div class="tab-navigation">
            <button id="filterTabBtn">Filter</button>
            <button id="listTabBtn" class="active-tab">Lista</button>
            <button id="mapTabBtn" onclick="checkIMggg()">Karta</button>
        </div>

        <div class="tab-content-container">
            <!-- Filter Tab Content -->
            <div id="filter-tab" class="tab-pane">
                <div class="device-list-controls">
                    <button id="clearSearchBtnMobile">Obriši pretragu</button>
                </div>
                <div class="search-filter-container">
                    <input type="text"
                           id="searchNameMobile"
                           placeholder="Pretraži po nazivu..." />
                    <select id="filterTypeMobile">
                        <option value="">Svi tipovi</option>
                        <option value="1">Admin</option>
                        <option value="2">Privatno</option>
                        <option value="3">Statično</option>
                    </select>
                    <div class="battery-filter-group">
                        <label for="filterBatteryMobile">Baterija:</label>
                        <select id="filterBatteryMobile">
                            <option value="">Svi</option>
                            <option value="10">&lt; 10%</option>
                            <option value="50">&lt; 50%</option>
                            <option value="70">&lt; 70%</option>
                            <option value="80">&lt; 80%</option>
                            <option value="90">&lt; 90%</option>
                        </select>
                    </div>
                    <div class="distance-filter-group">
                        <label for="filterDistanceMobile">Udaljenost (m):</label>
                        <select id="filterDistanceMobile">
                            <option value="">Svi</option>
                            <option value="5">&gt; 5m</option>
                            <option value="10">&gt; 10m</option>
                            <option value="20">&gt; 20m</option>
                            <option value="30">&gt; 30m</option>
                            <option value="40">&gt; 40m</option>
                            <option value="50">&gt; 50m</option>
                            <option value="70">&gt; 70m</option>
                            <option value="100">&gt; 100m</option>
                        </select>
                    </div>
                    <div class="last-update-filter-group">
                        <label for="filterLastUpdateMobile">Zadnja Izmjena (min):</label>
                        <select id="filterLastUpdateMobile">
                            <option value="">Svi</option>
                            <option value="10">&gt; 10 min</option>
                            <option value="20">&gt; 20 min</option>
                            <option value="30">&gt; 30 min</option>
                            <option value="40">&gt; 40 min</option>
                            <option value="50">&gt; 50 min</option>
                            <option value="100">&gt; 100 min</option>
                        </select>
                    </div>
                </div>
            </div>

            <!-- List Tab Content -->
            <div id="list-tab" class="tab-pane active">
                <div class="device-list-controls">
                    <button id="addDeviceBtnMobile">Dodaj uređaj</button>
                    <button id="refreshDevicesBtnMobile">Osvježi</button>
                </div>
                <div class="device-list" id="deviceListMobile">
                    <!-- Device items will be loaded here -->
                </div>
            </div>

            <!-- Map Tab Content -->
            <div id="map-tab" class="tab-pane">
                <div id="mapMobile"></div>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settingsModal" class="modal">
        <div class="modal-content">
            <h2>Postavke Aplikacije</h2>
            <p>Molimo unesite svoje API ključeve i naziv tablice u JSON formatu:</p>
            <textarea id="settingsInput" placeholder='{
"MapKey": "YOUR_GOOGLE_MAPS_API_KEY",
"ApiUrl": "YOUR_SUPABASE_URL",
"ApiKey": "YOUR_SUPABASE_ANON_KEY",
"TableName": "your_table_name"
}'></textarea>
            <div class="form-group">
                <label for="warningDistanceInput">Udaljenost upozorenja (m):</label>
                <input type="number" id="warningDistanceInput" min="0" placeholder="npr. 10" />
            </div>
            <div class="form-group">
                <label for="criticalDistanceInput">Kritična udaljenost (m):</label>
                <input type="number" id="criticalDistanceInput" min="0" placeholder="npr. 50" />
            </div>
            <!-- Novi inputi za postavke zadnje izmjene -->
            <div class="form-group">
                <label for="warningLastUpdateInput">Upozorenje zadnje izmjene (min):</label>
                <input type="number" id="warningLastUpdateInput" min="0" placeholder="npr. 20" />
            </div>
            <div class="form-group">
                <label for="criticalLastUpdateInput">Kritična zadnja izmjena (min):</label>
                <input type="number" id="criticalLastUpdateInput" min="0" placeholder="npr. 50" />
            </div>
            <!-- Novi inputi za postavke baterije -->
            <div class="form-group">
                <label for="batteryWarningInput">Upozorenje baterije (%):</label>
                <input type="number" id="batteryWarningInput" min="0" max="100" placeholder="npr. 20" />
            </div>
            <div class="form-group">
                <label for="batteryCriticalInput">Kritična baterija (%):</label>
                <input type="number" id="batteryCriticalInput" min="0" max="100" placeholder="npr. 5" />
            </div>
            <!-- Novi input za interval osvježavanja -->
            <div class="form-group">
                <label for="refreshIntervalInput">Interval Osvježavanja (sekunde):</label>
                <input type="number" id="refreshIntervalInput" min="0" placeholder="npr. 30 (0 za isključeno)" />
            </div>
            <!-- Novi input za dopuštanje notifikacija -->
            <div class="form-group">
                <label for="allowNotificationsToggle">Dopusti Automatske Notifikacije:</label>
                <label class="toggle-switch" style="margin-left: 10px;">
                    <input type="checkbox" id="allowNotificationsToggle" />
                    <span class="slider"></span>
                </label>
            </div>
            <div class="form-actions">
                <button type="button" class="cancel-btn" id="cancelSettingsBtn">Odustani</button>
                <button id="saveSettingsBtn" class="submit-btn">Spremi postavke</button>
            </div>
        </div>
    </div>

    <!-- Device Form Modal (Add/Edit) -->
    <div id="deviceFormModal" class="modal device-form-modal">
        <div class="modal-content">
            <h2 id="deviceFormTitle">Dodaj novi uređaj</h2>
            <form id="deviceForm">
                <div class="form-group">
                    <label for="deviceId">ID:</label>
                    <input type="text" id="deviceId" readonly />
                </div>
                <div class="form-group">
                    <label for="deviceName">Naziv:</label>
                    <input type="text" id="deviceName" placeholder="Naziv (opcionalno)" />
                </div>
                <div class="form-group">
                    <label for="deviceBattery">Baterija (%):</label>
                    <input type="number"
                           id="deviceBattery"
                           min="0"
                           max="100"
                           placeholder="0-100 (opcionalno)" />
                </div>
                <div class="form-group">
                    <label for="deviceLat">Latituda:</label>
                    <input type="number"
                           id="deviceLat"
                           step="any"
                           placeholder="npr. 45.815 (opcionalno)" />
                </div>
                <div class="form-group">
                    <label for="deviceLon">Longituda:</label>
                    <input type="number"
                           id="deviceLon"
                           step="any"
                           placeholder="npr. 15.982 (opcionalno)" />
                </div>
                <div class="form-group">
                    <label for="deviceStartLat">Početna Latituda (Opcionalno):</label>
                    <input type="number"
                           id="deviceStartLat"
                           step="any"
                           placeholder="npr. 45.810 (opcionalno)" />
                </div>
                <div class="form-group">
                    <label for="deviceStartLon">Početna Longitudu (Opcionalno):</label>
                    <input type="number"
                           id="deviceStartLon"
                           step="any"
                           placeholder="npr. 15.975 (opcionalno)" />
                </div>
                <div class="form-group">
                    <label for="deviceType">Tip:</label>
                    <select id="deviceType">
                        <option value="">Odaberi tip (opcionalno)</option>
                        <option value="1">Admin</option>
                        <option value="2">Privatno</option>
                        <option value="3">Statično</option>
                    </select>
                </div>
                <div class="form-actions">
                    <button type="button" class="cancel-btn" id="cancelDeviceFormBtn">
                        Odustani
                    </button>
                    <button type="submit" class="submit-btn">Spremi uređaj</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Custom Message Modal -->
    <div id="messageModal" class="modal">
        <div class="modal-content">
            <h2 id="messageModalTitle"></h2>
            <p id="messageModalContent"></p>
            <button id="messageModalCloseBtn">OK</button>
        </div>
    </div>

    <!-- Custom Confirmation Modal -->
    <div id="confirmModal" class="modal confirm-modal">
        <div class="modal-content">
            <h2 id="confirmModalTitle"></h2>
            <p id="confirmModalContent"></p>
            <div class="modal-buttons">
                <button id="confirmModalCancelBtn" class="cancel-btn">Odustani</button>
                <button id="confirmModalConfirmBtn" class="confirm-btn">Potvrdi</button>
            </div>
        </div>
    </div>

    <!-- Vaš custom JavaScript kod -->
    <script>
        let map = null; // Global map instance
        let markers = [];
        let infoWindows = []; // Dodano za praćenje InfoWindowa
        let polylines = []; // Dodano za praćenje Polylinea
        let config = {}; // Globalni objekt za pohranu konfiguracije
        let devices = [];
        let currentEditDeviceId = null;
        let activeMarker = null;
        let refreshTimerId = null; // Global variable to hold the setInterval ID
        let myLocationMarker = null; // Global variable for user's current location marker

        // Ažuriran CONFIG_KEYS da uključuje WarningDistance, CriticalDistance, LastUpdateWarningMinutes i LastUpdateCriticalMinutes
        const CONFIG_KEYS = ["MapKey", "ApiUrl", "ApiKey", "TableName", "WarningDistance", "CriticalDistance", "LastUpdateWarningMinutes", "LastUpdateCriticalMinutes", "RefreshInterval", "BatteryWarningPercentage", "BatteryCriticalPercentage", "AllowNotifications"];
        const DARK_MODE_KEY = "darkModeEnabled";
        const FILTER_STATE_KEY = "filterState"; // Novi ključ za stanje filtera
        // DISTANCE_WARNING_THRESHOLD_METERS i CRITICAL_DISTANCE_THRESHOLD_METERS će se sada učitavati iz konfiguracije
        let DISTANCE_WARNING_THRESHOLD_METERS = 10; // Defaultna vrijednost
        let CRITICAL_DISTANCE_THRESHOLD_METERS = 50; // Defaultna vrijednost za kritičnu udaljenost
        let LAST_UPDATE_WARNING_THRESHOLD_MINUTES = 20; // Defaultna vrijednost
        let LAST_UPDATE_CRITICAL_THRESHOLD_MINUTES = 50; // Defaultna vrijednost
        let REFRESH_INTERVAL_SECONDS = 30; // Default value for refresh interval
        let BATTERY_WARNING_PERCENTAGE = 20; // Defaultna vrijednost za upozorenje baterije
        let BATTERY_CRITICAL_PERCENTAGE = 5; // Defaultna vrijednost za kritičnu bateriju

        const SAME_LOCATION_EPSILON_METERS = 1; // Prag za smatranje lokacija istima (u metrima)

        // Mapping for device types
        const DEVICE_TYPES = {
            1: "Admin",
            2: "Privatno",
            3: "Statično"
        };

        // DOM Elements
        const settingsModal = document.getElementById("settingsModal");
        const settingsInput = document.getElementById("settingsInput");
        const saveSettingsBtn = document.getElementById("saveSettingsBtn");
        const settingsBtn = document.getElementById("settingsBtn");
        const cancelSettingsBtn = document.getElementById("cancelSettingsBtn");
        const warningDistanceInput = document.getElementById("warningDistanceInput");
        const criticalDistanceInput = document.getElementById("criticalDistanceInput"); // Novi input za kritičnu udaljenost
        const warningLastUpdateInput = document.getElementById("warningLastUpdateInput"); // Novi input
        const criticalLastUpdateInput = document.getElementById("criticalLastUpdateInput"); // Novi input
        const batteryWarningInput = document.getElementById("batteryWarningInput"); // New input for battery warning
        const batteryCriticalInput = document.getElementById("batteryCriticalInput"); // New input for battery critical
        const refreshIntervalInput = document.getElementById("refreshIntervalInput"); // New input for refresh interval
        const testNotificationBtn = document.getElementById("testNotificationBtn"); // New button for testing notifications
        const myLocationBtn = document.getElementById("myLocationBtn"); // New button for current location
        const allowNotificationsToggle = document.getElementById("allowNotificationsToggle"); // New toggle for notifications


        // Desktop/Tablet Elements
        const deviceListDesktop = document.getElementById("deviceList");
        const addDeviceBtnDesktop = document.getElementById("addDeviceBtn");
        const refreshDevicesBtnDesktop = document.getElementById("refreshDevicesBtn");
        const clearSearchBtnDesktop = document.getElementById("clearSearchBtn");
        const searchNameInputDesktop = document.getElementById("searchName");
        const filterTypeSelectDesktop = document.getElementById("filterType");
        const filterBatterySelectDesktop = document.getElementById("filterBattery");
        const filterDistanceSelectDesktop = document.getElementById("filterDistance");
        const filterLastUpdateSelectDesktop = document.getElementById("filterLastUpdate");
        const mapContainerDesktop = document.getElementById("map");


        const deviceFormModal = document.getElementById("deviceFormModal");
        const deviceFormTitle = document.getElementById("deviceFormTitle");
        const deviceForm = document.getElementById("deviceForm");
        const cancelDeviceFormBtn = document.getElementById("cancelDeviceFormBtn");
        const deviceIdInput = document.getElementById("deviceId");
        const deviceNameInput = document.getElementById("deviceName");
        const deviceBatteryInput = document.getElementById("deviceBattery");
        const deviceLatInput = document.getElementById("deviceLat");
        const deviceLonInput = document.getElementById("deviceLon");
        const deviceStartLatInput = document.getElementById("deviceStartLat");
        const deviceStartLonInput = document.getElementById("deviceStartLon");
        const deviceTypeInput = document.getElementById("deviceType");

        // Mobile Elements (newly added/renamed for clarity)
        const filterTabBtn = document.getElementById("filterTabBtn");
        const listTabBtn = document.getElementById("listTabBtn");
        const mapTabBtn = document.getElementById("mapTabBtn");
        const filterTabPane = document.getElementById("filter-tab");
        const listTabPane = document.getElementById("list-tab");
        const mapTabPane = document.getElementById("map-tab");

        const clearSearchBtnMobile = document.getElementById("clearSearchBtnMobile");
        const searchNameInputMobile = document.getElementById("searchNameMobile");
        const filterTypeSelectMobile = document.getElementById("filterTypeMobile");
        const filterBatterySelectMobile = document.getElementById("filterBatteryMobile");
        const filterDistanceSelectMobile = document.getElementById("filterDistanceMobile");
        const filterLastUpdateSelectMobile = document.getElementById("filterLastUpdateMobile");
        const addDeviceBtnMobile = document.getElementById("addDeviceBtnMobile");
        const refreshDevicesBtnMobile = document.getElementById("refreshDevicesBtnMobile");
        const deviceListMobile = document.getElementById("deviceListMobile");
        const mapContainerMobile = document.getElementById("mapMobile");


        // Custom Message Modal Elements (kept for other messages, but not for warnings)
        const messageModal = document.getElementById("messageModal");
        const messageModalTitle = document.getElementById("messageModalTitle");
        const messageModalContent = document.getElementById("messageModalContent");
        const messageModalCloseBtn = document.getElementById("messageModalCloseBtn");

        // Custom Confirmation Modal Elements
        const confirmModal = document.getElementById("confirmModal");
        const confirmModalTitle = document.getElementById("confirmModalTitle");
        const confirmModalContent = document.getElementById("confirmModalContent");
        const confirmModalConfirmBtn = document.getElementById("confirmModalConfirmBtn");
        const confirmModalCancelBtn = document.getElementById("confirmModalCancelBtn");

        let confirmCallback = null; // Callback funkcija za potvrdu

        // --- Utility Functions ---
        function showModal(modalElement) {
            modalElement.style.display = "flex";
        }

        function hideModal(modalElement) {
            modalElement.style.display = "none";
        }

        function showMessage(title, message) {
            messageModalTitle.textContent = title;
            messageModalContent.textContent = message;
            showModal(messageModal);
        }

        // Funkcija za prikaz potvrde
        function showConfirm(title, message, callback) {
            confirmModalTitle.textContent = title;
            confirmModalContent.textContent = message;
            confirmCallback = callback; // Postavi callback
            showModal(confirmModal);
        }

        function getBatteryColor(batteryPercentage) {
            if (batteryPercentage < 10) {
                return "var(--battery-low)";
            } else if (batteryPercentage < 50) {
                return "var(--battery-medium)";
            } else {
                return "var(--battery-high)";
            }
        }

        function getBatteryClass(batteryPercentage) {
            if (batteryPercentage < 10) {
                return "battery-low-color";
            } else if (batteryPercentage < 50) {
                return "battery-medium-color";
            } else {
                return "battery-high-color";
            }
        }

        function applyDarkMode(enabled) {
            if (enabled) {
                document.body.classList.add("dark-mode");
            } else {
                document.body.classList.remove("dark-mode");
            }
            localStorage.setItem(DARK_MODE_KEY, enabled);
        }

        /**
         * Calculates the distance between two lat/lon points in meters.
         * Uses the Haversine formula for better accuracy.
         * @param {number} lat1 - Latitude of point 1
         * @param {number} lon1 - Longitude of point 1
         * @param {number} lat2 - Latitude of point 2
         * @param {number} lon2 - Longitude of point 2
         * @returns {number} Distance in meters
         */
        function calculateDistance(lat1, lon1, lat2, lon2) {
            if ([lat1, lon1, lat2, lon2].some(coord => typeof coord !== 'number' || isNaN(coord))) {
                return Infinity; // Return infinity if coordinates are not valid numbers
            }

            const R = 6371e3; // Earth's radius in meters
            const phi1 = lat1 * Math.PI / 180; // φ, λ in radians
            const phi2 = lat2 * Math.PI / 180;
            const deltaPhi = (lat2 - lat1) * Math.PI / 180;
            const deltaLambda = (lon2 - lon1) * Math.PI / 180;

            const a = Math.sin(deltaPhi / 2) * Math.sin(deltaPhi / 2) +
                Math.cos(phi1) * Math.cos(phi2) *
                Math.sin(deltaLambda / 2) * Math.sin(deltaLambda / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

            const distance = R * c; // in meters
            return distance;
        }

        /**
         * Calculates the time difference between now and a given timestamp in minutes.
         * @param {string} timestamp - ISO 8601 timestamp string (e.g., "2023-07-21T10:30:00Z").
         * @returns {number} Difference in minutes, or Infinity if timestamp is invalid.
         */
        function calculateTimeDifferenceInMinutes(timestamp) {
            if (!timestamp) return Infinity;
            const lastUpdateDate = new Date(timestamp);
            if (isNaN(lastUpdateDate.getTime())) { // Check for invalid date
                return Infinity;
            }
            const now = new Date();
            const diffMs = now.getTime() - lastUpdateDate.getTime();
            return diffMs / (1000 * 60); // Difference in minutes
        }

        // --- Configuration Handling ---
        function loadConfig() {
            const storedConfig = localStorage.getItem("appConfig");
            if (storedConfig) {
                try {
                    config = JSON.parse(storedConfig);
                } catch (e) {
                    console.error("Greška pri parsiranju spremljene konfiguracije:", e);
                    showMessage("Greška konfiguracije", "Spremljena konfiguracija je neispravna. Molimo unesite ponovno.");
                    config = {}; // Reset config to empty if parsing fails
                }
            } else {
                config = {}; // Initialize empty config if nothing in localStorage
            }

            // Ensure all config keys have a value, setting defaults if missing or invalid
            // String keys - default to empty string
            config.MapKey = config.MapKey || "";
            config.ApiUrl = config.ApiUrl || "";
            config.ApiKey = config.ApiKey || "";
            config.TableName = config.TableName || "";

            // Numeric keys - default to specific numbers if not valid numbers
            config.WarningDistance = (typeof config.WarningDistance === 'number' && !isNaN(config.WarningDistance)) ? config.WarningDistance : 10;
            config.CriticalDistance = (typeof config.CriticalDistance === 'number' && !isNaN(config.CriticalDistance)) ? config.CriticalDistance : 50;
            config.LastUpdateWarningMinutes = (typeof config.LastUpdateWarningMinutes === 'number' && !isNaN(config.LastUpdateWarningMinutes)) ? config.LastUpdateWarningMinutes : 20;
            config.CriticalLastUpdateMinutes = (typeof config.CriticalLastUpdateMinutes === 'number' && !isNaN(config.CriticalLastUpdateMinutes)) ? config.CriticalLastUpdateMinutes : 50;
            config.RefreshInterval = (typeof config.RefreshInterval === 'number' && !isNaN(config.RefreshInterval)) ? config.RefreshInterval : 30;
            config.BatteryWarningPercentage = (typeof config.BatteryWarningPercentage === 'number' && !isNaN(config.BatteryWarningPercentage)) ? config.BatteryWarningPercentage : 20;
            config.BatteryCriticalPercentage = (typeof config.BatteryCriticalPercentage === 'number' && !isNaN(config.BatteryCriticalPercentage)) ? config.BatteryCriticalPercentage : 5;
            // New: AllowNotifications
            config.AllowNotifications = (typeof config.AllowNotifications === 'boolean') ? config.AllowNotifications : true;


            // Now update the global threshold variables from the (now guaranteed valid) config object
            DISTANCE_WARNING_THRESHOLD_METERS = config.WarningDistance;
            CRITICAL_DISTANCE_THRESHOLD_METERS = config.CriticalDistance;
            LAST_UPDATE_WARNING_THRESHOLD_MINUTES = config.LastUpdateWarningMinutes;
            LAST_UPDATE_CRITICAL_THRESHOLD_MINUTES = config.CriticalLastUpdateMinutes;
            REFRESH_INTERVAL_SECONDS = config.RefreshInterval;
            BATTERY_WARNING_PERCENTAGE = config.BatteryWarningPercentage;
            BATTERY_CRITICAL_PERCENTAGE = config.BatteryCriticalPercentage;

            // Validation check only for critical string keys that *must* be present and non-empty
            const criticalStringKeys = ["MapKey", "ApiUrl", "ApiKey", "TableName"];
            const missingCriticalStringKeys = criticalStringKeys.filter(key => !config[key]); // Checks for empty string, null, undefined

            if (missingCriticalStringKeys.length > 0) {
                showMessage("Greška konfiguracije", `Nedostaju obavezni konfiguracijski ključevi: ${missingCriticalStringKeys.join(", ")}`);
                return false;
            } else {
                return true;
            }
        }

        function saveConfig(cfg) {
            localStorage.setItem("appConfig", JSON.stringify(cfg));
            config = cfg;
            // Ažuriraj DISTANCE_WARNING_THRESHOLD_METERS nakon spremanja
            if (typeof config.WarningDistance === 'number' && !isNaN(config.WarningDistance)) {
                DISTANCE_WARNING_THRESHOLD_METERS = config.WarningDistance;
            } else {
                DISTANCE_WARNING_THRESHOLD_METERS = 10; // Vrati na default ako nije valjano
            }
            // Ažuriraj CRITICAL_DISTANCE_THRESHOLD_METERS nakon spremanja
            if (typeof config.CriticalDistance === 'number' && !isNaN(config.CriticalDistance)) {
                CRITICAL_DISTANCE_THRESHOLD_METERS = config.CriticalDistance;
            } else {
                CRITICAL_DISTANCE_THRESHOLD_METERS = 50; // Vrati na default ako nije valjano
            }
            // Ažuriraj LAST_UPDATE_WARNING_THRESHOLD_MINUTES nakon spremanja
            if (typeof config.LastUpdateWarningMinutes === 'number' && !isNaN(config.LastUpdateWarningMinutes)) {
                LAST_UPDATE_WARNING_THRESHOLD_MINUTES = config.LastUpdateWarningMinutes;
            } else {
                LAST_UPDATE_WARNING_THRESHOLD_MINUTES = 20; // Vrati na default ako nije valjano
            }
            // Ažuriraj LAST_UPDATE_CRITICAL_THRESHOLD_MINUTES nakon spremanja
            if (typeof config.CriticalLastUpdateMinutes === 'number' && !isNaN(config.CriticalLastUpdateMinutes)) {
                LAST_UPDATE_CRITICAL_THRESHOLD_MINUTES = config.CriticalLastUpdateMinutes;
            } else {
                LAST_UPDATE_CRITICAL_THRESHOLD_MINUTES = 50; // Vrati na default ako nije valjano
            }
            // Ažuriraj REFRESH_INTERVAL_SECONDS nakon spremanja
            if (typeof config.RefreshInterval === 'number' && !isNaN(config.RefreshInterval)) {
                REFRESH_INTERVAL_SECONDS = config.RefreshInterval;
            } else {
                REFRESH_INTERVAL_SECONDS = 30; // Vrati na default ako nije valjano
            }
            // Ažuriraj BATTERY_WARNING_PERCENTAGE nakon spremanja
            if (typeof config.BatteryWarningPercentage === 'number' && !isNaN(config.BatteryWarningPercentage)) {
                BATTERY_WARNING_PERCENTAGE = config.BatteryWarningPercentage;
            } else {
                BATTERY_WARNING_PERCENTAGE = 20; // Vrati na default ako nije valjano
            }
            // Ažuriraj BATTERY_CRITICAL_PERCENTAGE nakon spremanja
            if (typeof config.BatteryCriticalPercentage === 'number' && !isNaN(config.BatteryCriticalPercentage)) {
                BATTERY_CRITICAL_PERCENTAGE = config.BatteryCriticalPercentage;
            } else {
                BATTERY_CRITICAL_PERCENTAGE = 5; // Vrati na default ako nije valjano
            }
            // Ažuriraj AllowNotifications nakon spremanja
            config.AllowNotifications = cfg.AllowNotifications;


            hideModal(settingsModal);
            // Nakon spremanja konfiguracije, inicijaliziramo mapu i dohvaćamo uređaje
            initMap();
            fetchDevices();
            startAutoRefresh(); // Start/restart auto-refresh
        }

        function showConfigModal() {
            // Postavi trenutnu konfiguraciju u textarea prije prikazivanja modala
            settingsInput.value = JSON.stringify({
                MapKey: config.MapKey || "",
                ApiUrl: config.ApiUrl || "",
                ApiKey: config.ApiKey || "",
                TableName: config.TableName || "",
                WarningDistance: config.WarningDistance !== undefined && config.WarningDistance !== null ? config.WarningDistance : 10,
                CriticalDistance: config.CriticalDistance !== undefined && config.CriticalDistance !== null ? config.CriticalDistance : 50,
                LastUpdateWarningMinutes: config.LastUpdateWarningMinutes !== undefined && config.LastUpdateWarningMinutes !== null ? config.LastUpdateWarningMinutes : 20,
                CriticalLastUpdateMinutes: config.CriticalLastUpdateMinutes !== undefined && config.CriticalLastUpdateMinutes !== null ? config.CriticalLastUpdateMinutes : 50,
                BatteryWarningPercentage: config.BatteryWarningPercentage !== undefined && config.BatteryWarningPercentage !== null ? config.BatteryWarningPercentage : 20,
                BatteryCriticalPercentage: config.BatteryCriticalPercentage !== undefined && config.BatteryCriticalPercentage !== null ? config.BatteryCriticalPercentage : 5,
                RefreshInterval: config.RefreshInterval !== undefined && config.RefreshInterval !== null ? config.RefreshInterval : 30,
                AllowNotifications: config.AllowNotifications !== undefined && config.AllowNotifications !== null ? config.AllowNotifications : true,
            }, null, 2);
            // Postavi vrijednost u polja za udaljenost upozorenja i kritičnu udaljenost
            warningDistanceInput.value = config.WarningDistance !== undefined && config.WarningDistance !== null ? config.WarningDistance : 10;
            criticalDistanceInput.value = config.CriticalDistance !== undefined && config.CriticalDistance !== null ? config.CriticalDistance : 50;
            warningLastUpdateInput.value = config.LastUpdateWarningMinutes !== undefined && config.LastUpdateWarningMinutes !== null ? config.LastUpdateWarningMinutes : 20;
            criticalLastUpdateInput.value = config.CriticalLastUpdateMinutes !== undefined && config.CriticalLastUpdateMinutes !== null ? config.CriticalLastUpdateMinutes : 50;
            batteryWarningInput.value = config.BatteryWarningPercentage !== undefined && config.BatteryWarningPercentage !== null ? config.BatteryWarningPercentage : 20;
            batteryCriticalInput.value = config.BatteryCriticalPercentage !== undefined && config.BatteryCriticalPercentage !== null ? config.BatteryCriticalPercentage : 5;
            refreshIntervalInput.value = config.RefreshInterval !== undefined && config.RefreshInterval !== null ? config.RefreshInterval : 30;
            allowNotificationsToggle.checked = config.AllowNotifications; // Set checkbox state
            showModal(settingsModal);
        }

        // --- Supabase REST API Calls (using fetch) ---
        async function callSupabaseApi(method, body = null, id = null) {
            const { ApiUrl, ApiKey, TableName } = config;
            if (!ApiUrl || !ApiKey || !TableName) {
                console.error("Supabase API URL, ključ ili naziv tablice nedostaju u konfiguraciji.");
                showMessage("Greška konfiguracije", "Supabase URL, ključ ili naziv tablice nedostaju. Molimo provjerite konfiguraciju.");
                return null;
            }

            let url = `${ApiUrl}/rest/v1/${TableName}`;
            if (id) {
                url += `?id=eq.${id}`;
            } else if (method === 'GET') {
                url += `?select=id,data,lastUpdate`; // Dodano lastUpdate
            }

            const headers = {
                'Content-Type': 'application/json',
                'apikey': ApiKey,
                'Authorization': `Bearer ${ApiKey}`
            };

            // Dodaj Prefer zaglavlje za POST/PATCH kako bi se osiguralo vraćanje reprezentacije
            // Ovo je ključno za korisnikov prijavljeni radni isječak
            if (method === 'POST' || method === 'PATCH') {
                headers['Prefer'] = 'return=representation';
            }

            try {
                console.log(`Slanje API zahtjeva: ${method} ${url}`);
                console.log(`Zahtjevani body:`, body); // Zabilježi body koji se šalje
                const res = await fetch(url, {
                    method: method,
                    headers: headers,
                    body: body ? JSON.stringify(body) : undefined,
                });

                console.log(`Primljen API odgovor za ${method} ${url}. Status: ${res.status}`);
                console.log(`Response headers:`, res.headers); // Zabilježi zaglavlja odgovora

                // Ako je status 204 No Content, nema tijela za parsiranje
                if (res.status === 204) {
                    console.log("Status odgovora je 204 No Content. Vraćam true.");
                    return true;
                }

                // Pokušaj pročitati tijelo odgovora kao tekst prvo kako bi se izbjegle 'Unexpected end of JSON input' greške
                // ako je Content-Type pogrešan ili je tijelo prazno, ali status nije 204.
                const responseText = await res.text();
                console.log(`Raw response text: "${responseText}"`);

                // Provjeri je li responseText prazan ili samo prazni znakovi
                const hasContent = responseText.trim().length > 0;

                // Provjeri Content-Type zaglavlje
                const contentType = res.headers.get('content-type');
                const isJson = contentType && contentType.includes('application/json');

                if (!res.ok) {
                    // Ako odgovor nije OK, baci grešku s bilo kojim sadržajem koji smo dobili
                    let errorMessage = `Supabase API greška (${res.status})`;
                    if (hasContent) {
                        try {
                            // Pokušaj parsirati kao JSON ako izgleda kao JSON za bolje detalje greške
                            const errorJson = JSON.parse(responseText);
                            errorMessage += `: ${JSON.stringify(errorJson)}`;
                        } catch (e) {
                            errorMessage += `: ${responseText}`;
                        }
                    } else {
                        errorMessage += `: Nema tijela odgovora`;
                    }
                    throw new Error(errorMessage);
                }

                // Ako je odgovor OK (npr. 200, 201) i ima sadržaj
                if (hasContent && isJson) {
                    try {
                        return JSON.parse(responseText);
                    } catch (e) {
                        console.error("Greška pri parsiranju JSON odgovora:", e, "Raw response:", responseText);
                        throw new Error(`Greška pri parsiranju JSON odgovora: ${e.message}. Odgovor: "${responseText}"`);
                    }
                } else if (res.ok && !hasContent) {
                    // Ako je OK, ali nema sadržaja (npr. 200 OK s praznim tijelom, ili 201 Created s praznim tijelom ako je Prefer ignoriran)
                    console.warn(`Neočekivani prazan odgovor za ${method} ${url}. Status: ${res.status}.`);
                    return true; // Tretiraj kao uspjeh ako je OK, ali nema sadržaja
                } else {
                    // Ako je OK, ali nije JSON (npr. običan tekst ili neočekivani format)
                    console.warn(`Neočekivani non-JSON tip sadržaja za ${method} ${url}. Status: ${res.status}. Odgovor: "${responseText}"`);
                    return responseText; // Vrati sirovi tekst ili null na temelju očekivanog ponašanja
                }

            } catch (error) {
                console.error(`Greška tijekom Supabase API ${method} poziva na ${url}:`, error.message);
                showMessage("API Greška", `Došlo je do greške prilikom komunikacije sa Supabase: ${error.message}`);
                return null;
            }
        }

        async function fetchDevices() {
            try {
                const data = await callSupabaseApi('GET');
                if (data) {
                    // Provjerite format podataka. Mapirajte ih iz { id: ..., data: { ... }, lastUpdate: ... } u { id: ..., lastUpdate: ..., ... }
                    devices = data.map((item) => ({ id: item.id, lastUpdate: item.lastUpdate, ...item.data }));
                    console.log("Dohvaćeni uređaji:", devices);

                    let allWarnings = [];
                    devices.forEach(device => {
                        const warnings = getDeviceStatusWarnings(device);
                        if (warnings) {
                            allWarnings.push(`- ${device.name || 'N/A'} (ID: ${device.id}): ${warnings}`);
                        }
                    });

                    if (allWarnings.length > 0) {
                        // Attempt to show a web notification if permission is granted AND allowed in settings
                        if (Notification.permission === 'granted' && config.AllowNotifications) {
                            const notificationTitle = "Upozorenja o Uređajima!";
                            const notificationOptions = {
                                body: allWarnings.join('\n'),
                                icon: 'https://placehold.co/48x48/FF0000/FFFFFF?text=!W', // Example warning icon
                                tag: 'device-warnings', // Group notifications
                                renotify: true // Show new notification even if one with the same tag exists
                            };
                            navigator.serviceWorker.ready.then(registration => {
                                registration.showNotification(notificationTitle, notificationOptions);
                                // After sending notification, disable automatic notifications
                                config.AllowNotifications = false;
                                saveConfig(config); // Save the updated config
                                // The message below will now be shown via the standard message modal
                                showMessage("Notifikacije", "Upozorenje je poslano. Automatske notifikacije su privremeno isključene. Molimo ponovno omogućite u postavkama.");
                            });
                        }
                        // Removed the else block that showed "Upozorenja o Uređajima" modal
                        // if notifications were not granted or allowed in settings.
                    }

                } else {
                    devices = []; // Očisti uređaje ako nema podataka ili je došlo do greške
                }
            } catch (error) {
                // Greške se već obrađuju u callSupabaseApi
                devices = []; // Očisti uređaje kod greške
            } finally {
                // Uvijek osvježi listu i markere bez obzira na uspjeh dohvaćanja
                renderDeviceList();
                updateMapMarkers();
            }
        }

        async function addDevice(device) {
            try {
                // Dodaj current timestamp kao lastUpdate
                const deviceWithTimestamp = { ...device, lastUpdate: new Date().toISOString() };
                const data = await callSupabaseApi('POST', { data: deviceWithTimestamp });
                // Supabase POST obično vraća 201 Created s podacima ili 204 No Content.
                // Ako je data truthy (tj. nije null, false, 0, '', undefined), to je uspjeh.
                if (data) {
                    showMessage("Uspjeh", "Uređaj uspješno dodan!");
                    hideModal(deviceFormModal);
                    fetchDevices(); // Ponovno dohvati i osvježi sve
                }
            }
            catch (error) {
                // Greške se već obrađuju u callSupabaseApi
            }
        }

        async function updateDevice(id, updatedData) {
            try {
                // Ažuriraj lastUpdate na trenutni timestamp prilikom svake izmjene
                const updatedDataWithTimestamp = { ...updatedData, lastUpdate: new Date().toISOString() };
                const result = await callSupabaseApi('PATCH', { data: updatedDataWithTimestamp }, id);
                if (result) { // Uključuje i true za 204 No Content
                    showMessage("Uspjeh", "Uređaj uspješno ažuriran!");
                    hideModal(deviceFormModal);
                    fetchDevices(); // Ponovno dohvati i osvježi sve
                }
            }
            catch (error) {
                // Greške se već obrađuju u callSupabaseApi
            }
        }

        async function deleteDevice(id) {
            showConfirm("Potvrda brisanja", "Jeste li sigurni da želite obrisati ovaj uređaj?", async (confirmed) => {
                if (confirmed) {
                    try {
                        const result = await callSupabaseApi('DELETE', null, id);
                        if (result) { // result će biti true ako je 204 No Content
                            showMessage("Uspjeh", "Uređaj uspješno obrisan!");
                            fetchDevices(); // Ponovno dohvati i osvježi sve
                        }
                    }
                    catch (error) {
                        // Greške se već obrađuju u callSupabaseApi
                    }
                }
            });
        }

        /**
         * Checks a device for various warning/critical conditions and returns a formatted string of warnings.
         * @param {object} device - The device object to check.
         * @returns {string} A comma-separated string of warnings, or an empty string if no warnings.
         */
        function getDeviceStatusWarnings(device) {
            const warnings = [];

            // Battery Warning/Critical
            if (device.battery !== undefined && device.battery !== null) {
                if (device.battery < BATTERY_CRITICAL_PERCENTAGE) {
                    warnings.push(`Baterija kritična (${device.battery}%)`);
                } else if (device.battery < BATTERY_WARNING_PERCENTAGE) {
                    warnings.push(`Baterija upozorenje (${device.battery}%)`);
                }
            }

            // Distance Warning/Critical
            const hasCurrentCoords = typeof device.lat === 'number' && typeof device.lon === 'number' && !isNaN(device.lat) && !isNaN(device.lon);
            const hasStartCoords = typeof device.startLat === 'number' && typeof device.startLon === 'number' && !isNaN(device.startLat) && !isNaN(device.startLon);
            if (hasCurrentCoords && hasStartCoords) {
                const distance = calculateDistance(device.lat, device.lon, device.startLat, device.startLon);
                if (distance > CRITICAL_DISTANCE_THRESHOLD_METERS) {
                    warnings.push(`Udaljenost kritična (${distance.toFixed(2)}m)`);
                } else if (distance > DISTANCE_WARNING_THRESHOLD_METERS) {
                    warnings.push(`Udaljenost upozorenje (${distance.toFixed(2)}m)`);
                }
            }

            // Last Update Warning/Critical
            const timeDiffMinutes = calculateTimeDifferenceInMinutes(device.lastUpdate);
            if (timeDiffMinutes !== Infinity) {
                if (timeDiffMinutes > LAST_UPDATE_CRITICAL_THRESHOLD_MINUTES) {
                    warnings.push(`Zadnja izmjena kritična (${timeDiffMinutes.toFixed(0)} min)`);
                } else if (timeDiffMinutes > LAST_UPDATE_WARNING_THRESHOLD_MINUTES) {
                    warnings.push(`Zadnja izmjena upozorenje (${timeDiffMinutes.toFixed(0)} min)`);
                }
            }

            return warnings.join(', ');
        }

        // New helper function to move the map's DOM element
        function moveMapElement(mapDiv, targetContainer) {
            if (mapDiv && targetContainer && mapDiv.parentNode !== targetContainer) {
                targetContainer.appendChild(mapDiv);
                console.log(`Map DOM element moved to: ${targetContainer.id}`);
            }
        }

        // --- Map Functions ---
        function initMap() {
            if (!config.MapKey) {
                console.error("Google Maps API ključ nedostaje. Karta se ne može učitati.");
                showMessage("Greška karte", "Google Maps API ključ nedostaje. Karta se ne može učitati.");
                return;
            }
            // Only append script once
            if (!window.google || !window.google.maps) {
                const script = document.createElement("script");
                script.src = `https://maps.googleapis.com/maps/api/js?key=${config.MapKey}&callback=initGoogleMaps`;
                script.async = true;
                document.body.appendChild(script);
            } else {
                // If API is already loaded, just call the callback
                initGoogleMaps();
            }
        }

        // Ova funkcija se poziva automatski kada se učita Google Maps API
        window.initGoogleMaps = () => {
            const defaultLatLng = { lat: 45.815, lng: 15.982 }; // Koordinate Zagreba

            // Always initialize map on the desktop container first
            if (!map) {
                map = new google.maps.Map(mapContainerDesktop, { // Always use mapContainerDesktop for initial creation
                    center: defaultLatLng,
                    zoom: 8,
                });
                console.log("Map initialized on desktop container:", mapContainerDesktop.id);

                map.addListener('click', (e) => {
                    if (!e.placeId && !e.featureId && !e.latLng.x && !e.latLng.y) {
                        deselectActiveDevice();
                    }
                });
            } else {
                // If map already exists, just ensure it's on the desktop container and resize
                moveMapElement(map.getDiv(), mapContainerDesktop);
                google.maps.event.trigger(map, 'resize');
                console.log("Map already initialized, ensured it's on desktop container and resized.");
            }
            updateMapMarkers();
        };

        function deselectActiveDevice() {
            if (activeMarker) {
                // Reset the icon of the previously active marker
                const device = devices.find((d) => d.id === activeMarker.deviceId);
                if (device) {
                    const batteryColor = getBatteryColor(device.battery);
                    if (activeMarker.isCurrentLocation) {
                        activeMarker.setIcon({
                            path: google.maps.SymbolPath.SQUARE,
                            scale: 12,
                            fillColor: batteryColor,
                            fillOpacity: 0.9,
                            strokeWeight: 1.5,
                            strokeColor: "#333",
                        });
                    } else if (activeMarker.isStartLocation) {
                        activeMarker.setIcon({
                            path: google.maps.SymbolPath.CIRCLE,
                            scale: 10,
                            fillColor: '#888888',
                            fillOpacity: 0.8,
                            strokeWeight: 1.5,
                            strokeColor: "#333",
                        });
                    }
                }
            }
            activeMarker = null;
            highlightDeviceListItem(null); // Remove active class from list item
            infoWindows.forEach(iw => iw.close()); // Close all info windows
        }


        /**
         * Returns a filtered list of devices based on current search and filter inputs.
         * It dynamically chooses which set of input fields (desktop or mobile) to read from
         * based on the current window width.
         * @returns {Array} An array of filtered device objects.
         */
        function getFilteredDevices() {
            let searchTerm, filterTypeValue, filterBatteryValue, filterDistanceValue, filterLastUpdateValue;

            if (window.innerWidth > 768) { // Desktop/Tablet
                searchTerm = searchNameInputDesktop.value.toLowerCase().normalize('NFC');
                filterTypeValue = filterTypeSelectDesktop.value;
                filterBatteryValue = parseInt(filterBatterySelectDesktop.value);
                filterDistanceValue = parseFloat(filterDistanceSelectDesktop.value);
                filterLastUpdateValue = parseFloat(filterLastUpdateSelectDesktop.value);
            } else { // Mobile
                searchTerm = searchNameInputMobile.value.toLowerCase().normalize('NFC');
                filterTypeValue = filterTypeSelectMobile.value;
                filterBatteryValue = parseInt(filterBatterySelectMobile.value);
                filterDistanceValue = parseFloat(filterDistanceSelectMobile.value);
                filterLastUpdateValue = parseFloat(filterLastUpdateSelectMobile.value);
            }


            return devices.filter((device) => {
                const deviceNameNormalized = (device.name || '').toLowerCase().normalize('NFC');
                const matchesName = !searchTerm || deviceNameNormalized.includes(searchTerm);

                const matchesType = filterTypeValue
                    ? String(device.type) === filterTypeValue
                    : true;
                const matchesBattery = filterBatteryValue
                    ? (device.battery !== undefined && device.battery !== null && device.battery < filterBatteryValue)
                    : true;

                let matchesDistance = true;
                if (filterDistanceValue) {
                    const hasCurrentCoords = typeof device.lat === 'number' && typeof device.lon === 'number' && !isNaN(device.lat) && !isNaN(device.lon);
                    const hasStartCoords = typeof device.startLat === 'number' && typeof device.startLon === 'number' && !isNaN(device.startLat) && !isNaN(device.startLon);

                    if (hasCurrentCoords && hasStartCoords) {
                        const distance = calculateDistance(device.lat, device.lon, device.startLat, device.startLon);
                        matchesDistance = distance > filterDistanceValue;
                    } else {
                        matchesDistance = false; // If no coords, cannot match distance filter
                    }
                }

                let matchesLastUpdate = true;
                if (filterLastUpdateValue) {
                    const timeDiff = calculateTimeDifferenceInMinutes(device.lastUpdate);
                    matchesLastUpdate = timeDiff > filterLastUpdateValue;
                }

                return matchesName && matchesType && matchesBattery && matchesDistance && matchesLastUpdate;
            });
        }

        function updateMapMarkers() {
            if (!map) {
                console.warn("Karta nije inicijalizirana, preskačem ažuriranje markera.");
                return;
            }

            // Clear existing InfoWindows
            infoWindows.forEach(iw => iw.close());
            infoWindows = [];

            // Clear existing device markers and polylines
            markers.forEach((marker) => marker.setMap(null));
            markers = [];
            polylines.forEach((line) => line.setMap(null));
            polylines = [];

            // Clear my location marker if it exists
            if (myLocationMarker) {
                myLocationMarker.setMap(null);
                myLocationMarker = null;
            }

            // Get currently filtered devices
            const filteredDevices = getFilteredDevices();

            filteredDevices.forEach((device) => {
                const hasCurrentCoords = typeof device.lat === 'number' && typeof device.lon === 'number' && !isNaN(device.lat) && !isNaN(device.lon);
                const hasStartCoords = typeof device.startLat === 'number' && typeof device.startLon === 'number' && !isNaN(device.startLat) && !isNaN(device.startLon);

                let currentPos = hasCurrentCoords ? { lat: device.lat, lng: device.lon } : null;
                let startPos = hasStartCoords ? { lat: device.startLat, lng: device.startLon } : null;

                let distance = Infinity;
                if (hasCurrentCoords && hasStartCoords) {
                    distance = calculateDistance(device.lat, device.lon, device.startLat, device.startLon);
                }

                const isSameLocation = distance <= SAME_LOCATION_EPSILON_METERS;

                let primaryMarker = null; // Marker to which InfoWindow is attached and map pans to
                let currentLocMarker = null; // Marker for current location (square)
                let startLocMarker = null;  // Marker for start location (circle)

                // 1. Create marker for START location (always a circle if startLat/Lon exists)
                if (hasStartCoords) {
                    const startMarkerIcon = {
                        path: google.maps.SymbolPath.CIRCLE,
                        scale: 10,
                        fillColor: '#888888', // Grey for start location
                        fillOpacity: 0.8,
                        strokeWeight: 1.5,
                        strokeColor: "#333",
                    };
                    startLocMarker = new google.maps.Marker({
                        position: startPos,
                        map: map,
                        title: `Početna: ${device.name || 'N/A'}`,
                        icon: startMarkerIcon,
                        deviceId: device.id,
                        isStartLocation: true // Custom property to identify
                    });
                    markers.push(startLocMarker);
                }

                // 2. Create marker for CURRENT location (square, conditional display)
                // Display current marker if:
                //   a) Has current coordinates AND
                //   b) (No start coordinates OR distance is > DISTANCE_WARNING_THRESHOLD_METERS)
                if (hasCurrentCoords && (!hasStartCoords || distance > DISTANCE_WARNING_THRESHOLD_METERS)) {
                    const batteryColor = getBatteryColor(device.battery);
                    const currentMarkerIcon = {
                        path: google.maps.SymbolPath.SQUARE,
                        scale: 12,
                        fillColor: batteryColor,
                        fillOpacity: 0.9,
                        strokeWeight: 1.5,
                        strokeColor: "#333",
                    };
                    currentLocMarker = new google.maps.Marker({
                        position: currentPos,
                        map: map,
                        title: `Trenutna: ${device.name || 'N/A'} (${device.battery !== undefined && device.battery !== null ? device.battery : 'N/A'}%)`,
                        icon: currentMarkerIcon,
                        deviceId: device.id,
                        isCurrentLocation: true // Custom property to identify
                    });
                    markers.push(currentLocMarker);
                }

                // Determine which marker is primary for InfoWindow and panToMarker
                // Prioritize current location marker (square) if displayed, otherwise start location marker (circle)
                primaryMarker = currentLocMarker || startLocMarker;

                // 3. Create Polyline if both current and start coordinates exist and are not in the same place
                if (hasCurrentCoords && hasStartCoords && !isSameLocation) {
                    const devicePath = new google.maps.Polyline({
                        path: [currentPos, startPos],
                        geodesic: true,
                        strokeColor: '#FF0000',
                        strokeOpacity: 0.8,
                        strokeWeight: 2
                    });
                    devicePath.setMap(map);
                    polylines.push(devicePath);
                }


                // InfoWindow content
                let coordsInfo = '';
                if (hasCurrentCoords) {
                    coordsInfo += `<p><strong>Trenutna Pozicija:</strong> Lat: ${device.lat.toFixed(4)}, Lon: ${device.lon.toFixed(4)}</p>`;
                }
                if (hasStartCoords) {
                    coordsInfo += `<p><strong>Početna Pozicija:</strong> Lat: ${device.startLat.toFixed(4)}, Lon: ${device.startLon.toFixed(4)}</p>`;
                }
                if (hasCurrentCoords && hasStartCoords) {
                    let distanceText = `${distance.toFixed(2)} metara`;
                    let distanceStyle = '';
                    if (distance > CRITICAL_DISTANCE_THRESHOLD_METERS) {
                        distanceStyle = `style="color: ${getComputedStyle(document.documentElement).getPropertyValue('--critical-color').trim()}; font-weight: bold;"`;
                    } else if (distance > DISTANCE_WARNING_THRESHOLD_METERS) {
                        distanceStyle = `style="color: ${getComputedStyle(document.documentElement).getPropertyValue('--warning-color').trim()}; font-weight: bold;"`;
                    }
                    coordsInfo += `<p><strong>Udaljenost:</strong> <span ${distanceStyle}>${distanceText}</span></p>`;
                } else if (!hasCurrentCoords && !hasStartCoords) {
                    coordsInfo += `<p>Nema koordinata</p>`;
                }

                const timeDiffMinutes = calculateTimeDifferenceInMinutes(device.lastUpdate);
                let lastUpdateText = timeDiffMinutes !== Infinity ? `Prije ${timeDiffMinutes.toFixed(0)} min` : `N/A`;
                let lastUpdateStyle = '';
                if (timeDiffMinutes > LAST_UPDATE_CRITICAL_THRESHOLD_MINUTES) {
                    lastUpdateStyle = `style="color: ${getComputedStyle(document.documentElement).getPropertyValue('--critical-color').trim()}; font-weight: bold;"`;
                } else if (timeDiffMinutes > LAST_UPDATE_WARNING_THRESHOLD_MINUTES) {
                    lastUpdateStyle = `style="color: ${getComputedStyle(document.documentElement).getPropertyValue('--warning-color').trim()}; font-weight: bold;"`;
                }
                const lastUpdateInfo = `<p><strong>Zadnja Izmjena:</strong> <span ${lastUpdateStyle}>${lastUpdateText}</span></p>`;

                const deviceTypeText = DEVICE_TYPES[device.type] || 'N/A'; // Get textual type

                const batteryColorForText = getBatteryColor(device.battery);
                const contentString = `
                                                <div style="color: black;">
                                                    <h3>${device.name || 'N/A'}</h3>
                                                    <p><strong>ID:</strong> ${device.id}</p>
                                                    <p><strong>Baterija:</strong> <span style="color: ${batteryColorForText}; font-weight: bold;">${device.battery !== undefined && device.battery !== null ? device.battery : 'N/A'}%</span></p>
                                                    <p><strong>Tip:</strong> ${deviceTypeText}</p>
                                                    ${coordsInfo}
                                                    ${lastUpdateInfo}
                                                </div>
                                            `;

                if (primaryMarker) {
                    const infoWindow = new google.maps.InfoWindow({
                        content: contentString,
                    });
                    infoWindows.push(infoWindow);

                    primaryMarker.addListener("click", () => {
                        infoWindows.forEach(iw => iw.close());
                        infoWindow.open(map, primaryMarker);
                        highlightDeviceListItem(device.id);
                    });
                    // Add listener for InfoWindow close button
                    infoWindow.addListener('closeclick', () => {
                        deselectActiveDevice();
                    });
                }
            });

            // Ensure the currently active marker is also highlighted on the map
            if (activeMarker) {
                // Find the currently active marker among the newly displayed markers.
                let currentActiveMarkerOnMap = markers.find(m => m.deviceId === activeMarker.deviceId &&
                    ((m.isCurrentLocation && activeMarker.isCurrentLocation) ||
                        (m.isStartLocation && activeMarker.isStartLocation)));

                if (currentActiveMarkerOnMap) {
                    highlightMarker(currentActiveMarkerOnMap);
                } else {
                    // If the previously active marker is no longer displayed (e.g., removed due to filter),
                    // clear the active state.
                    activeMarker = null;
                    highlightDeviceListItem(null);
                }
            }
        }

        function panToMarker(deviceId) {
            // Attempt to find the current location marker (square) for centering
            let marker = markers.find((m) => m.deviceId === deviceId && m.isCurrentLocation);
            // If square marker doesn't exist, try to find the start location marker (circle)
            if (!marker) {
                marker = markers.find((m) => m.deviceId === deviceId && m.isStartLocation);
            }

            if (marker) {
                map.panTo(marker.getPosition());
                // Simulate click to open info window (this will close others)
                google.maps.event.trigger(marker, "click");
                highlightMarker(marker);
            } else {
                console.warn(`Marker for device ID ${deviceId} not found. Cannot pan map.`);
            }
            highlightDeviceListItem(deviceId);
        }

        function highlightMarker(markerToHighlight) {
            // Reset the style of the previously active marker
            if (activeMarker && activeMarker !== markerToHighlight) {
                const device = devices.find((d) => d.id === activeMarker.deviceId);
                if (device) {
                    const batteryColor = getBatteryColor(device.battery);
                    // Revert to standard icon depending on marker type
                    if (activeMarker.isCurrentLocation) { // If it was a square
                        activeMarker.setIcon({
                            path: google.maps.SymbolPath.SQUARE,
                            scale: 12, // Revert to standard scale
                            fillColor: batteryColor,
                            fillOpacity: 0.9,
                            strokeWeight: 1.5,
                            strokeColor: "#333",
                        });
                    } else if (activeMarker.isStartLocation) { // If it was a circle
                        activeMarker.setIcon({
                            path: google.maps.SymbolPath.CIRCLE,
                            scale: 10,
                            fillColor: '#888888',
                            fillOpacity: 0.8,
                            strokeWeight: 1.5,
                            strokeColor: "#333",
                        });
                    }
                }
            }

            // Set the style of the new active marker
            activeMarker = markerToHighlight;
            if (activeMarker) {
                const device = devices.find((d) => d.id === activeMarker.deviceId);
                if (device) {
                    const batteryColor = getBatteryColor(device.battery);
                    // Apply highlighting based on marker type
                    if (activeMarker.isCurrentLocation) { // If it's a square
                        activeMarker.setIcon({
                            path: google.maps.SymbolPath.SQUARE,
                            scale: 14, // Larger scale for active
                            fillColor: batteryColor,
                            fillOpacity: 1,
                            strokeWeight: 2.5,
                            strokeColor: "#000",
                        });
                    } else if (activeMarker.isStartLocation) { // If it's a circle
                        activeMarker.setIcon({
                            path: google.maps.SymbolPath.CIRCLE,
                            scale: 12, // Larger scale for active circle
                            fillColor: '#666666', /* Darker grey for highlighting */
                            fillOpacity: 1,
                            strokeWeight: 2.5,
                            strokeColor: "#000",
                        });
                    }
                }
            }
        }

        // --- Device List Rendering and Interaction ---
        function renderDeviceList() {
            // Determine which device list to render to based on screen size
            const currentDeviceList = window.innerWidth > 768 ? deviceListDesktop : deviceListMobile;
            if (!currentDeviceList) return; // Exit if no list element found

            currentDeviceList.innerHTML = ""; // Clear existing list

            // Get filtered devices using the helper function
            const sortedAndFilteredDevices = getFilteredDevices().sort((a, b) => a.id - b.id);

            if (sortedAndFilteredDevices.length === 0 && devices.length > 0) {
                console.warn("Nema uređaja koji odgovaraju trenutnim filterima.");
                currentDeviceList.innerHTML = '<p style="padding: 10px; text-align: center;">Nema uređaja koji odgovaraju kriterijima pretrage.</p>';
            } else if (devices.length === 0) {
                console.log("Nema uređaja za prikaz.");
                currentDeviceList.innerHTML = '<p style="padding: 10px; text-align: center;">Nema dodanih uređaja. Dodajte jedan!</p>';
            }

            sortedAndFilteredDevices.forEach((device) => {
                const deviceItem = document.createElement("div");
                deviceItem.classList.add("device-item");
                deviceItem.dataset.id = device.id;

                let distanceIconHtml = '';
                let lastUpdateIconHtml = '';
                let batteryWarningIconHtml = ''; // New for battery warning icon
                let batteryCriticalIconHtml = ''; // New for battery critical icon

                let distanceInfoText = '';
                let lastUpdateInfoText = '';
                let distanceTextColor = '';
                let lastUpdateTextColor = '';

                const hasCurrentCoords = typeof device.lat === 'number' && typeof device.lon === 'number' && !isNaN(device.lat) && !isNaN(device.lon);
                const hasStartCoords = typeof device.startLat === 'number' && typeof device.startLon === 'number' && !isNaN(device.startLat) && !isNaN(device.startLon);

                if (hasCurrentCoords && hasStartCoords) {
                    const distance = calculateDistance(device.lat, device.lon, device.startLat, device.startLon);
                    distanceInfoText = `Udaljenost: ${distance.toFixed(2)}m`;
                    if (distance > CRITICAL_DISTANCE_THRESHOLD_METERS) {
                        distanceIconHtml = `
                                    <span class="critical-icon" title="Kritično upozorenje: Velika razlika u poziciji!">
                                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                                            <path d="M12 2L1 21h22L12 2zm-1 14h2v-2h-2v2zm0-4h2V8h-2v4z"/>
                                        </svg>
                                    </span>`;
                        distanceTextColor = 'var(--critical-color)';
                    } else if (distance > DISTANCE_WARNING_THRESHOLD_METERS) {
                        distanceIconHtml = `
                                    <span class="warning-icon" title="Upozorenje: Velika razlika u poziciji!">
                                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                                            <path d="M12 2L1 21h22L12 2zm-1 14h2v-2h-2v2zm0-4h2V8h-2v4z"/>
                                        </svg>
                                    </span>`;
                        distanceTextColor = 'var(--warning-color)';
                    }
                }

                const timeDiffMinutes = calculateTimeDifferenceInMinutes(device.lastUpdate);
                if (timeDiffMinutes !== Infinity) {
                    lastUpdateInfoText = `Zadnja izmjena: Prije ${timeDiffMinutes.toFixed(0)} min`;
                    if (timeDiffMinutes > LAST_UPDATE_CRITICAL_THRESHOLD_MINUTES) {
                        lastUpdateIconHtml = `
                                    <span class="critical-icon" title="Kritično upozorenje: Zadnja izmjena prije ${timeDiffMinutes.toFixed(0)} min!">
                                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                                            <path d="M12 2L1 21h22L12 2zm-1 14h2v-2h-2v2zm0-4h2V8h-2v4z"/>
                                        </svg>
                                    </span>`;
                        lastUpdateTextColor = 'var(--critical-color)';
                    } else if (timeDiffMinutes > LAST_UPDATE_WARNING_THRESHOLD_MINUTES) {
                        lastUpdateIconHtml = `
                                    <span class="warning-icon" title="Upozorenje: Zadnja izmjena prije ${timeDiffMinutes.toFixed(0)} min!">
                                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                                            <path d="M12 2L1 21h22L12 2zm-1 14h2v-2h-2v2zm0-4h2V8h-2v4z"/>
                                        </svg>
                                    </span>`;
                        lastUpdateTextColor = 'var(--warning-color)';
                    }
                } else {
                    lastUpdateInfoText = "Zadnja izmjena: N/A";
                }

                // Battery warning/critical icons
                if (device.battery !== undefined && device.battery !== null) {
                    if (device.battery < BATTERY_CRITICAL_PERCENTAGE) {
                        batteryCriticalIconHtml = `
                                <span class="critical-icon" title="Kritično upozorenje: Baterija ${device.battery}%!">
                                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                                        <path d="M12 2L1 21h22L12 2zm-1 14h2v-2h-2v2zm0-4h2V8h-2v4z"/>
                                    </svg>
                                </span>`;
                    } else if (device.battery < BATTERY_WARNING_PERCENTAGE) {
                        batteryWarningIconHtml = `
                                <span class="warning-icon" title="Upozorenje: Baterija ${device.battery}%!">
                                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                                        <path d="M12 2L1 21h22L12 2zm-1 14h2v-2h-2v2zm0-4h2V8h-2v4z"/>
                                    </svg>
                                </span>`;
                    }
                }

                let currentCoordsDisplay = '';
                if (hasCurrentCoords) {
                    currentCoordsDisplay = `Trenutna: Lat: ${device.lat.toFixed(4)}, Lon: ${device.lon.toFixed(4)}`;
                } else {
                    currentCoordsDisplay = "Trenutna: N/A";
                }

                let startCoordsDisplay = '';
                if (hasStartCoords) {
                    startCoordsDisplay = `Početna: Lat: ${device.startLat.toFixed(4)}, Lon: ${device.startLon.toFixed(4)}`;
                } else {
                    startCoordsDisplay = "Početna: N/A";
                }

                const deviceTypeText = DEVICE_TYPES[device.type] || 'N/A'; // Get textual type


                deviceItem.innerHTML = `
                                            <div class="device-info-row">
                                                <div class="device-name">${device.name || 'N/A'}</div>
                                            </div>
                                            <div class="device-icons-and-buttons">
                                                <div class="device-icons">
                                                    <div class="battery-status ${getBatteryClass(device.battery)}">
                                                        <span class="battery-icon">
                                                            <span class="battery-level" style="width: ${device.battery || 0}%"></span>
                                                        </span>
                                                        ${device.battery !== undefined && device.battery !== null ? device.battery : 'N/A'}%
                                                    </div>
                                                    ${batteryWarningIconHtml}
                                                    ${batteryCriticalIconHtml}
                                                    ${distanceIconHtml}
                                                    ${lastUpdateIconHtml}
                                                </div>
                                                <div class="device-actions">
                                                    <!-- Buttons will be appended here dynamically -->
                                                </div>
                                            </div>
                                            <small>Tip: ${deviceTypeText}</small>
                                            <small>${currentCoordsDisplay}</small>
                                            <small>${startCoordsDisplay}</small>
                                            <small><span style="color: ${distanceTextColor || 'inherit'};">${distanceInfoText}</span></small>
                                            <small><span style="color: ${lastUpdateTextColor || 'inherit'};">${lastUpdateInfoText}</span></small>
                                        `;

                // Create and append Edit button
                const editButton = document.createElement('button');
                editButton.textContent = 'Uredi';
                editButton.classList.add('edit-btn'); // Add new class
                editButton.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent device item click
                    editDevice(device.id);
                });
                deviceItem.querySelector('.device-actions').appendChild(editButton);

                // Create and append Delete button
                const deleteButton = document.createElement('button');
                deleteButton.textContent = 'Obriši';
                deleteButton.classList.add('delete-btn'); // Add new class
                deleteButton.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent device item click
                    deleteDevice(device.id);
                });
                deviceItem.querySelector('.device-actions').appendChild(deleteButton);


                deviceItem.addEventListener("click", (e) => {
                    // Prevent triggering on button click (already handled by e.stopPropagation() on buttons)
                    // but keep the check if other interactive elements are added within device-item
                    if (
                        e.target.tagName === "BUTTON" ||
                        e.target.closest(".device-actions")
                    ) {
                        return;
                    }
                    // Call panToMarker only if the device has coordinates
                    if (hasCurrentCoords || hasStartCoords) { // Pan to any available coordinate
                        panToMarker(device.id);
                    } else {
                        console.log(`Uređaj ${device.id} nema koordinate, ne može se pomaknuti karta.`);
                    }
                    highlightDeviceListItem(device.id);
                });
                currentDeviceList.appendChild(deviceItem);
            });
            highlightDeviceListItem(
                activeMarker ? activeMarker.deviceId : null
            ); // Re-highlight if marker is active
        }

        function highlightDeviceListItem(deviceId) {
            document.querySelectorAll(".device-item").forEach((item) => {
                item.classList.remove("active");
            });
            if (deviceId) {
                // Check both desktop and mobile lists
                let activeItem = document.querySelector(`.device-list[id="deviceList"] .device-item[data-id="${deviceId}"]`);
                if (!activeItem) {
                    activeItem = document.querySelector(`.device-list[id="deviceListMobile"] .device-item[data-id="${deviceId}"]`);
                }

                if (activeItem) {
                    activeItem.classList.add("active");
                    activeItem.scrollIntoView({ behavior: "smooth", block: "nearest" });
                }
            }
        }

        function editDevice(id) {
            const device = devices.find((d) => d.id === id);
            if (device) {
                currentEditDeviceId = id;
                deviceFormTitle.textContent = `Uredi uređaj (ID: ${id})`;
                deviceIdInput.value = device.id;
                deviceNameInput.value = device.name || '';
                deviceBatteryInput.value = (device.battery !== undefined && device.battery !== null) ? device.battery : ''; // Empty string if null/undefined
                // Check for existence and validity of coordinates before setting
                deviceLatInput.value = (typeof device.lat === 'number' && !isNaN(device.lat)) ? device.lat : '';
                deviceLonInput.value = (typeof device.lon === 'number' && !isNaN(device.lon)) ? device.lon : '';
                deviceStartLatInput.value = (typeof device.startLat === 'number' && !isNaN(device.startLat)) ? device.startLat : '';
                deviceStartLonInput.value = (typeof device.startLon === 'number' && !isNaN(device.startLon)) ? device.startLon : '';
                deviceTypeInput.value = (device.type !== undefined && device.type !== null) ? device.type : ''; // Empty string if null/undefined
                showModal(deviceFormModal);
            }
        }

        function resetDeviceForm() {
            currentEditDeviceId = null;
            deviceFormTitle.textContent = "Dodaj novi uređaj";
            deviceForm.reset();
            deviceIdInput.value = ""; // Ensure ID is empty for new device
            deviceTypeInput.value = ""; // Set select to "Odaberi tip"
        }

        // --- Filter State Persistence ---
        function saveFilterState() {
            const isMobile = window.innerWidth <= 768;
            const filterState = {
                searchName: isMobile ? searchNameInputMobile.value : searchNameInputDesktop.value,
                filterType: isMobile ? filterTypeSelectMobile.value : filterTypeSelectDesktop.value,
                filterBattery: isMobile ? filterBatterySelectMobile.value : filterBatterySelectDesktop.value,
                filterDistance: isMobile ? filterDistanceSelectMobile.value : filterDistanceSelectDesktop.value,
                filterLastUpdate: isMobile ? filterLastUpdateSelectMobile.value : filterLastUpdateSelectDesktop.value
            };
            localStorage.setItem(FILTER_STATE_KEY, JSON.stringify(filterState));

            // Update URL
            const urlParams = new URLSearchParams();
            for (const key in filterState) {
                if (filterState[key]) { // Only add non-empty values to URL
                    urlParams.set(key, filterState[key]);
                }
            }
            const newUrl = `${window.location.pathname}?${urlParams.toString()}${window.location.hash}`;
            history.replaceState(filterState, '', newUrl); // Use replaceState to avoid cluttering history
        }

        function loadFilterState() {
            const urlParams = new URLSearchParams(window.location.search);
            let loadedState = {};

            if (urlParams.toString()) { // If URL has query parameters
                console.log("Loading filter state from URL parameters.");
                loadedState = {
                    searchName: urlParams.get('searchName') || '',
                    filterType: urlParams.get('filterType') || '',
                    filterBattery: urlParams.get('filterBattery') || '',
                    filterDistance: urlParams.get('filterDistance') || '',
                    filterLastUpdate: urlParams.get('filterLastUpdate') || ''
                };
            } else { // Otherwise, load from localStorage
                console.log("Loading filter state from localStorage.");
                const storedState = localStorage.getItem(FILTER_STATE_KEY);
                if (storedState) {
                    try {
                        loadedState = JSON.parse(storedState);
                    } catch (e) {
                        console.error("Greška pri parsiranju spremljenog stanja filtera:", e);
                        loadedState = {};
                    }
                }
            }

            // Apply loaded state to both desktop and mobile inputs
            searchNameInputDesktop.value = loadedState.searchName || '';
            filterTypeSelectDesktop.value = loadedState.filterType || '';
            filterBatterySelectDesktop.value = loadedState.filterBattery || '';
            filterDistanceSelectDesktop.value = loadedState.filterDistance || '';
            filterLastUpdateSelectDesktop.value = loadedState.filterLastUpdate || '';

            searchNameInputMobile.value = loadedState.searchName || '';
            filterTypeSelectMobile.value = loadedState.filterType || '';
            filterBatterySelectMobile.value = loadedState.batteryFilter || '';
            filterDistanceSelectMobile.value = loadedState.filterDistance || '';
            filterLastUpdateSelectMobile.value = loadedState.filterLastUpdate || '';
        }

        // --- Tab Management Functions (only for mobile) ---
        function showTab(tabId) {
            // Only execute if on mobile
            if (window.innerWidth > 768) return;

            // Hide all tab panes explicitly and remove active class
            document.querySelectorAll('.tab-pane').forEach(pane => {
                pane.classList.remove('active');
                pane.style.display = 'none'; // Explicitly hide
            });
            // Deactivate all tab buttons
            document.querySelectorAll('.tab-navigation button').forEach(button => {
                button.classList.remove('active-tab');
            });

            // Show the selected tab pane explicitly and add active class
            const activePane = document.getElementById(tabId);
            activePane.classList.add('active');
            activePane.style.display = 'flex'; // Explicitly show

            // Activate the corresponding tab button
            document.getElementById(`${tabId.replace('-tab', '')}TabBtn`).classList.add('active-tab');

            // If the map tab is activated, ensure the map is resized and redrawn
            if (tabId === 'map-tab') {
                if (map) {
                    // Move the existing map DOM element to the mobile map container
                    moveMapElement(map.getDiv(), mapContainerMobile);
                    google.maps.event.trigger(map, 'resize');
                    if (activeMarker) {
                        map.panTo(activeMarker.getPosition());
                    } else if (myLocationMarker) {
                        map.panTo(myLocationMarker.getPosition());
                    } else {
                        map.setCenter({ lat: 45.815, lng: 15.982 }); // Default center Zagreb
                    }
                } else {
                    // This case should ideally not happen if initMap is called on DOMContentLoaded
                    // but as a fallback, re-initialize if map is somehow null
                    initMap(); // This will create map on desktop container, then move it
                    if (map) { // Check if map was successfully initialized
                        moveMapElement(map.getDiv(), mapContainerMobile);
                        google.maps.event.trigger(map, 'resize');
                    }
                }
            } else {
                // If switching away from map tab on mobile, move map back to desktop container (which will be hidden)
                if (map && map.getDiv().parentNode === mapContainerMobile) {
                    moveMapElement(map.getDiv(), mapContainerDesktop);
                }
            }
            console.log(`Switched to tab: ${tabId}`);
        }

        // --- Auto Refresh Function ---
        function startAutoRefresh() {
            if (refreshTimerId) {
                clearInterval(refreshTimerId);
                refreshTimerId = null;
            }

            if (config.RefreshInterval > 0) {
                refreshTimerId = setInterval(fetchDevices, config.RefreshInterval * 1000);
                console.log(`Auto-refresh started every ${config.RefreshInterval} seconds.`);
            } else {
                console.log('Auto-refresh disabled.');
            }
        }

        // --- Notification Functions ---
        async function requestNotificationPermissionAndTest() {
            if (!('Notification' in window)) {
                showMessage("Notifikacije nisu podržane", "Vaš preglednik ne podržava web notifikacije.");
                return;
            }

            // Check if Service Worker is supported and registered
            if (!('serviceWorker' in navigator)) {
                showMessage("Service Worker nije podržan", "Vaš preglednik ne podržava Service Workere, notifikacije možda neće raditi ispravno.");
                return;
            }

            // Request permission
            const permission = await Notification.requestPermission();
            if (permission === 'granted') {
                showMessage("Dopuštenje za notifikacije", "Dopuštenje je odobreno. Pokušavam poslati testnu notifikaciju.");
                // Show a test notification via Service Worker
                navigator.serviceWorker.ready.then(registration => {
                    registration.showNotification('Testna Notifikacija', {
                        body: 'Ovo je testna notifikacija iz Upravitelja Uređajima.',
                        icon: 'https://placehold.co/48x48/007bff/FFFFFF?text=Test',
                        tag: 'test-notification',
                        renotify: true
                    });
                }).catch(error => {
                    console.error("Greška pri prikazivanju notifikacije putem Service Workera:", error);
                    showMessage("Greška notifikacije", "Nije moguće prikazati testnu notifikaciju putem Service Workera.");
                });
            } else if (permission === 'denied') {
                showMessage("Dopuštenje odbijeno", "Dopuštenje za notifikacije je odbijeno. Nećete primati obavijesti.");
            } else { // 'default'
                showMessage("Dopuštenje nije dano", "Dopuštenje za notifikacije nije dano. Molimo odobrite ga u postavkama preglednika.");
            }
        }

        // --- Geolocation Function ---
        function addCurrentLocationMarker() {
            if (!map) {
                showMessage("Greška karte", "Karta nije inicijalizirana. Molimo pričekajte ili provjerite konfiguraciju.");
                return;
            }

            if (!navigator.geolocation) {
                showMessage("Greška geolokacije", "Vaš preglednik ne podržava geolokaciju.");
                return;
            }

            showMessage("Geolokacija", "Pokušavam dohvatiti vašu trenutnu lokaciju...");

            navigator.geolocation.getCurrentPosition(
                (position) => {
                    const lat = position.coords.latitude;
                    const lng = position.coords.longitude;
                    const myLatLng = { lat: lat, lng: lng };

                    // Clear previous my location marker if it exists
                    if (myLocationMarker) {
                        myLocationMarker.setMap(null);
                    }

                    myLocationMarker = new google.maps.Marker({
                        position: myLatLng,
                        map: map,
                        title: 'Moja Trenutna Lokacija',
                        icon: {
                            path: google.maps.SymbolPath.CIRCLE,
                            scale: 10,
                            fillColor: '#007bff', // Blue color for my location
                            fillOpacity: 0.9,
                            strokeWeight: 1.5,
                            strokeColor: '#333',
                        },
                        zIndex: google.maps.Marker.MAX_ZINDEX + 1 // Ensure it's on top
                    });

                    const infoWindow = new google.maps.InfoWindow({
                        content: `<div style="color: black;"><h3>Moja Trenutna Lokacija</h3><p>Lat: ${lat.toFixed(4)}, Lon: ${lng.toFixed(4)}</p></div>`
                    });

                    myLocationMarker.addListener('click', () => {
                        infoWindows.forEach(iw => iw.close()); // Close other info windows
                        infoWindow.open(map, myLocationMarker);
                    });

                    infoWindow.addListener('closeclick', () => {
                        // Optionally remove the marker when info window is closed
                        // myLocationMarker.setMap(null);
                        // myLocationMarker = null;
                    });

                    map.panTo(myLatLng);
                    map.setZoom(15); // Zoom in on the user's location
                    showMessage("Geolokacija", `Vaša lokacija: Lat ${lat.toFixed(4)}, Lon ${lng.toFixed(4)}`);
                },
                (error) => {
                    let errorMessage = "Nije moguće dohvatiti vašu lokaciju.";
                    switch (error.code) {
                        case error.PERMISSION_DENIED:
                            errorMessage = "Dopuštenje za geolokaciju je odbijeno. Molimo odobrite ga u postavkama preglednika.";
                            break;
                        case error.POSITION_UNAVAILABLE:
                            errorMessage = "Informacije o lokaciji nisu dostupne.";
                            break;
                        case error.TIMEOUT:
                            errorMessage = "Isteklo je vrijeme za dohvatanje lokacije.";
                            break;
                        case error.UNKNOWN_ERROR:
                            errorMessage = "Došlo je do nepoznate pogreške geolokacije.";
                            break;
                    }
                    showMessage("Greška geolokacije", errorMessage);
                    console.error("Greška geolokacije:", error);
                },
                {
                    enableHighAccuracy: true,
                    timeout: 10000,
                    maximumAge: 0
                }
            );
        }


        // --- Event Listeners ---
        saveSettingsBtn.addEventListener("click", () => {
            try {
                const currentSettings = JSON.parse(settingsInput.value);
                const warningDistance = parseFloat(warningDistanceInput.value);
                const criticalDistance = parseFloat(criticalDistanceInput.value);
                const warningLastUpdate = parseFloat(warningLastUpdateInput.value);
                const criticalLastUpdate = parseFloat(criticalLastUpdateInput.value);
                const batteryWarning = parseFloat(batteryWarningInput.value); // Parse new battery warning
                const batteryCritical = parseFloat(batteryCriticalInput.value); // Parse new battery critical
                const refreshInterval = parseFloat(refreshIntervalInput.value);
                const allowNotifications = allowNotificationsToggle.checked; // Get new notification setting

                // Ažuriraj objekt postavki s vrijednosti iz input polja
                currentSettings.WarningDistance = isNaN(warningDistance) ? null : warningDistance;
                currentSettings.CriticalDistance = isNaN(criticalDistance) ? null : criticalDistance;
                currentSettings.LastUpdateWarningMinutes = isNaN(warningLastUpdate) ? null : warningLastUpdate;
                currentSettings.CriticalLastUpdateMinutes = isNaN(criticalLastUpdate) ? null : criticalLastUpdate;
                currentSettings.BatteryWarningPercentage = isNaN(batteryWarning) ? null : batteryWarning; // Assign new battery warning
                currentSettings.BatteryCriticalPercentage = isNaN(batteryCritical) ? null : batteryCritical; // Assign new battery critical
                currentSettings.RefreshInterval = isNaN(refreshInterval) ? null : refreshInterval;
                currentSettings.AllowNotifications = allowNotifications; // Assign new notification setting

                const missingKeys = CONFIG_KEYS.filter((key) => {
                    // Only check for non-empty strings for critical API/table keys
                    if (["MapKey", "ApiUrl", "ApiKey", "TableName"].includes(key)) {
                        return !currentSettings[key]; // True if empty string, null, or undefined
                    }
                    // For numeric and boolean keys, we allow null (which will default in loadConfig)
                    return false;
                });

                if (missingKeys.length > 0) {
                    showMessage("Greška konfiguracije", `Nedostaju obavezni konfiguracijski ključevi: ${missingKeys.join(", ")}`);
                    return;
                }
                saveConfig(currentSettings); // Proslijedi ažurirani objekt
            } catch (e) {
                showMessage("Greška konfiguracije", "Neispravan JSON format za konfiguraciju. Molimo provjerite svoj unos.");
            }
        });

        settingsBtn.addEventListener("click", showConfigModal);
        testNotificationBtn.addEventListener("click", requestNotificationPermissionAndTest); // New event listener
        myLocationBtn.addEventListener("click", addCurrentLocationMarker); // New event listener for my location

        cancelSettingsBtn.addEventListener("click", () => {
            hideModal(settingsModal);
        });

        // Add Device Buttons
        addDeviceBtnDesktop.addEventListener("click", () => {
            resetDeviceForm();
            showModal(deviceFormModal);
        });
        addDeviceBtnMobile.addEventListener("click", () => {
            resetDeviceForm();
            showModal(deviceFormModal);
        });

        // Refresh Devices Buttons
        refreshDevicesBtnDesktop.addEventListener("click", fetchDevices);
        refreshDevicesBtnMobile.addEventListener("click", fetchDevices);


        // Clear Search Buttons
        clearSearchBtnDesktop.addEventListener("click", () => {
            searchNameInputDesktop.value = '';
            filterTypeSelectDesktop.value = '';
            filterBatterySelectDesktop.value = '';
            filterDistanceSelectDesktop.value = '';
            filterLastUpdateSelectDesktop.value = '';
            saveFilterState(); // Save empty filter state
            renderDeviceList();
            updateMapMarkers();
        });
        clearSearchBtnMobile.addEventListener("click", () => {
            searchNameInputMobile.value = '';
            filterTypeSelectMobile.value = '';
            filterBatterySelectMobile.value = '';
            filterDistanceSelectMobile.value = '';
            filterLastUpdateSelectMobile.value = '';
            saveFilterState(); // Save empty filter state
            renderDeviceList();
            updateMapMarkers();
        });

        cancelDeviceFormBtn.addEventListener("click", () => {
            hideModal(deviceFormModal);
        });

        // Close message modal
        messageModalCloseBtn.addEventListener("click", () => {
            hideModal(messageModal);
        });

        // Confirm modal buttons
        confirmModalConfirmBtn.addEventListener("click", () => {
            hideModal(confirmModal);
            if (confirmCallback) {
                confirmCallback(true);
                confirmCallback = null; // Reset callback
            }
        });

        confirmModalCancelBtn.addEventListener("click", () => {
            hideModal(confirmModal);
            if (confirmCallback) {
                confirmCallback(false);
                confirmCallback = null; // Reset callback
            }
        });


        deviceForm.addEventListener("submit", (e) => {
            e.preventDefault();

            // Get values, allow empty strings for optional fields
            const nameValue = deviceNameInput.value.trim();
            const batteryValue = deviceBatteryInput.value.trim();
            const latValue = deviceLatInput.value.trim();
            const lonValue = deviceLonInput.value.trim();
            const startLatValue = deviceStartLatInput.value.trim();
            const startLonValue = deviceStartLonInput.value.trim();
            const typeValue = deviceTypeInput.value.trim();

            const deviceData = {
                // Name is optional
                name: nameValue === '' ? null : nameValue,
                // Battery and type are optional, convert to null if empty
                battery: batteryValue === '' ? null : parseInt(batteryValue),
                lat: latValue === '' ? null : parseFloat(latValue),
                lon: lonValue === '' ? null : parseFloat(lonValue),
                startLat: startLatValue === '' ? null : parseFloat(startLatValue),
                startLon: startLonValue === '' ? null : parseFloat(startLonValue),
                type: typeValue === '' ? null : parseInt(typeValue), // parseInt('') is NaN, so this becomes null
            };

            // Validation for battery if entered and not null
            if (deviceData.battery !== null && (isNaN(deviceData.battery) || deviceData.battery < 0 || deviceData.battery > 100)) {
                showMessage("Greška unosa", "Baterija mora biti broj između 0 i 100 ili prazno.");
                return;
            }
            // Validation for type if entered and not null
            if (deviceData.type !== null && isNaN(deviceData.type)) {
                showMessage("Greška unosa", "Tip uređaja mora biti broj ili prazno.");
                return;
            }

            // Validation for lat and lon if entered and not null
            if (deviceData.lat !== null && (isNaN(deviceData.lat) || deviceData.lat < -90 || deviceData.lat > 90)) {
                showMessage("Greška unosa", "Molimo unesite valjanu vrijednost za Latitudu (-90 do 90) ili ostavite prazno.");
                return;
            }
            if (deviceData.lon !== null && (isNaN(deviceData.lon) || deviceData.lon < -180 || deviceData.lon > 180)) {
                showMessage("Greška unosa", "Molimo unesite valjanu vrijednost za Longitudu (-180 do 180) ili ostavite prazno.");
                return;
            }
            // Validation for startLat and startLon if entered and not null
            if (deviceData.startLat !== null && (isNaN(deviceData.startLat) || deviceData.startLat < -90 || deviceData.startLat > 90)) {
                showMessage("Greška unosa", "Molimo unesite valjanu vrijednost za Početnu Latitudu (-90 do 90) ili ostavite prazno.");
                return;
            }
            if (deviceData.startLon !== null && (isNaN(deviceData.startLon) || deviceData.startLon < -180 || deviceData.startLon > 180)) {
                showMessage("Greška unosa", "Molimo unesite valjanu vrijednost za Početnu Longitudu (-180 do 180) ili ostavite prazno.");
                return;
            }


            if (currentEditDeviceId) {
                updateDevice(currentEditDeviceId, deviceData);
            } else {
                addDevice(deviceData);
            }
        });

        // Event listeners for desktop filters
        searchNameInputDesktop.addEventListener("input", () => {
            saveFilterState();
            renderDeviceList();
            updateMapMarkers();
        });
        filterTypeSelectDesktop.addEventListener("change", () => {
            saveFilterState();
            renderDeviceList();
            updateMapMarkers();
        });
        filterBatterySelectDesktop.addEventListener("change", () => {
            saveFilterState();
            renderDeviceList();
            updateMapMarkers();
        });
        filterDistanceSelectDesktop.addEventListener("change", () => {
            saveFilterState();
            renderDeviceList();
            updateMapMarkers();
        });
        filterLastUpdateSelectDesktop.addEventListener("change", () => {
            saveFilterState();
            renderDeviceList();
            updateMapMarkers();
        });

        // Event listeners for mobile filters
        searchNameInputMobile.addEventListener("input", () => {
            saveFilterState();
            renderDeviceList();
            updateMapMarkers();
        });
        filterTypeSelectMobile.addEventListener("change", () => {
            saveFilterState();
            renderDeviceList();
            updateMapMarkers();
        });
        filterBatterySelectMobile.addEventListener("change", () => {
            saveFilterState();
            renderDeviceList();
            updateMapMarkers();
        });
        filterDistanceSelectMobile.addEventListener("change", () => {
            saveFilterState();
            renderDeviceList();
            updateMapMarkers();
        });
        filterLastUpdateSelectMobile.addEventListener("change", () => {
            saveFilterState();
            renderDeviceList();
            updateMapMarkers();
        });


        darkModeToggle.addEventListener("change", (e) => {
            applyDarkMode(e.target.checked);
        });

        // Tab event listeners (only active on mobile due to CSS display: none)
        filterTabBtn.addEventListener('click', () => showTab('filter-tab'));
        listTabBtn.addEventListener('click', () => showTab('list-tab'));
        mapTabBtn.addEventListener('click', () => showTab('map-tab'));

        // Handle window resize to adjust layout and map
        window.addEventListener('resize', () => {
            const isMobile = window.innerWidth <= 768;

            // Show/hide main content sections based on screen size
            document.querySelector('.device-list-container').style.display = isMobile ? 'none' : 'flex';
            document.querySelector('.map-container').style.display = isMobile ? 'none' : 'flex';
            document.querySelector('.tab-navigation').style.display = isMobile ? 'flex' : 'none';
            document.querySelector('.tab-content-container').style.display = isMobile ? 'flex' : 'none';

            if (!isMobile) { // Switching to desktop view
                // Ensure map is on desktop container and resized
                if (map) {
                    moveMapElement(map.getDiv(), mapContainerDesktop);
                    google.maps.event.trigger(map, 'resize');
                }
                document.querySelectorAll('.tab-pane').forEach(pane => pane.classList.remove('active'));
                document.querySelectorAll('.tab-navigation button').forEach(button => button.classList.remove('active-tab'));
            } else { // Switching to mobile view
                // If the map tab is currently active on mobile, ensure map is on mobile container and resized
                const mapTabButton = document.getElementById('mapTabBtn');
                if (mapTabButton && mapTabButton.classList.contains('active-tab')) {
                    if (map) {
                        moveMapElement(map.getDiv(), mapContainerMobile);
                        google.maps.event.trigger(map, 'resize');
                    }
                } else {
                    // If switching to mobile and map tab is not active, ensure list tab is shown
                    const activeTabs = document.querySelectorAll('.tab-pane.active');
                    if (activeTabs.length === 0) {
                        showTab('list-tab'); // Default to list tab on mobile
                    }
                }
            }

            renderDeviceList(); // Re-render list to pick up correct list element
            updateMapMarkers(); // Update markers after map resize/move
        });


        // --- Inicijalizacija ---
        document.addEventListener("DOMContentLoaded", () => {
            // Učitaj postavke tamnog načina rada
            const isDarkMode = localStorage.getItem(DARK_MODE_KEY) === "true";
            darkModeToggle.checked = isDarkMode;
            applyDarkMode(isDarkMode);

            // Registriraj Service Worker
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register('/sw.js')
                    .then(function (registration) {
                        console.log('Service Worker registriran sa scope:', registration.scope);
                    })
                    .catch(function (error) {
                        console.error('Registracija Service Workera nije uspjela:', error);
                    });
            }


            // Učitaj konfiguraciju. Ako je valjana, inicijalizira mapu i dohvaća uređaje.
            if (loadConfig()) {
                loadFilterState(); // Load filter state before fetching devices
                initMap(); // This will now initialize the map on the desktop container
                fetchDevices();
                startAutoRefresh(); // Start auto-refresh on initial load

                // Initial layout adjustment based on screen size
                const isMobile = window.innerWidth <= 768;
                document.querySelector('.device-list-container').style.display = isMobile ? 'none' : 'flex';
                document.querySelector('.map-container').style.display = isMobile ? 'none' : 'flex';
                document.querySelector('.tab-navigation').style.display = isMobile ? 'flex' : 'none';
                document.querySelector('.tab-content-container').style.display = isMobile ? 'flex' : 'none';

                if (isMobile) {
                    showTab('list-tab'); // Default to list tab on mobile
                }
            } else {
                showConfigModal(); // Prikaži modal za konfiguraciju ako nema spremljenih podataka
            }
        });
    </script>
</body>
</html>
